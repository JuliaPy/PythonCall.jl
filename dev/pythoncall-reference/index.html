<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PythonCall &amp; JuliaCall</title><meta name="title" content="Reference · PythonCall &amp; JuliaCall"/><meta property="og:title" content="Reference · PythonCall &amp; JuliaCall"/><meta property="twitter:title" content="Reference · PythonCall &amp; JuliaCall"/><meta name="description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="og:description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="twitter:description" content="Documentation for PythonCall &amp; JuliaCall."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; JuliaCall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; JuliaCall</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">The Julia module PythonCall</span><ul><li><a class="tocitem" href="../pythoncall/">Guide</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Py-objects"><span><code>Py</code> objects</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Builtins"><span>Builtins</span></a></li><li><a class="tocitem" href="#Conversion-to-Julia"><span>Conversion to Julia</span></a></li><li><a class="tocitem" href="#Wrap-Julia-values"><span>Wrap Julia values</span></a></li><li><a class="tocitem" href="#Arithmetic"><span>Arithmetic</span></a></li><li><a class="tocitem" href="#Logic"><span>Logic</span></a></li><li><a class="tocitem" href="#Create-classes"><span>Create classes</span></a></li><li><a class="tocitem" href="#python-wrappers"><span>Wrapper types</span></a></li><li><a class="tocitem" href="#@py-and-@pyconst"><span><code>@py</code> and <code>@pyconst</code></span></a></li><li><a class="tocitem" href="#Multi-threading"><span>Multi-threading</span></a></li><li><a class="tocitem" href="#The-Python-interpreter"><span>The Python interpreter</span></a></li><li><a class="tocitem" href="#Low-level-API"><span>Low-level API</span></a></li><li><a class="tocitem" href="#NumpyDates"><span>NumpyDates</span></a></li></ul></li></ul></li><li><span class="tocitem">The Python module JuliaCall</span><ul><li><a class="tocitem" href="../juliacall/">Guide</a></li><li><a class="tocitem" href="../juliacall-reference/">Reference</a></li></ul></li><li><span class="tocitem">Conversion</span><ul><li><a class="tocitem" href="../conversion-to-python/">Julia to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Python to Julia</a></li></ul></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li><a class="tocitem" href="../faq/">FAQ &amp; Troubleshooting</a></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">The Julia module PythonCall</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl/blob/main/docs/src/pythoncall-reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="py-reference"><a class="docs-heading-anchor" href="#py-reference">PythonCall API Reference</a><a id="py-reference-1"></a><a class="docs-heading-anchor-permalink" href="#py-reference" title="Permalink"></a></h1><h2 id="Py-objects"><a class="docs-heading-anchor" href="#Py-objects"><code>Py</code> objects</a><a id="Py-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Py-objects" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PythonCall.Py"><a class="docstring-binding" href="#PythonCall.Py"><code>PythonCall.Py</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Py(x)</code></pre><p>Convert <code>x</code> to a Python object, of type <code>Py</code>.</p><p>Conversion happens according to <a href="../conversion-to-python/#jl2py-conversion">these rules</a>.</p><p>Such an object supports attribute access (<code>obj.attr</code>), indexing (<code>obj[idx]</code>), calling (<code>obj(arg1, arg2)</code>), iteration (<code>for x in obj</code>), arithmetic (<code>obj + obj2</code>) and comparison (<code>obj &gt; obj2</code>), among other things. These operations convert all their arguments to <code>Py</code> and return <code>Py</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L13-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pybuiltins"><a class="docstring-binding" href="#PythonCall.pybuiltins"><code>PythonCall.pybuiltins</code></a> — <span class="docstring-category">Module</span></summary><div><pre><code class="language-julia hljs">pybuiltins</code></pre><p>An object whose fields are the Python builtins, of type <a href="#PythonCall.Py"><code>Py</code></a>.</p><p>For example <code>pybuiltins.None</code>, <code>pybuiltins.int</code>, <code>pybuiltins.ValueError</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L42-L48">source</a></div></details></article><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>These functions construct Python objects of builtin types from Julia values.</p><article><details class="docstring" open="true"><summary id="PythonCall.pybool"><a class="docstring-binding" href="#PythonCall.pybool"><code>PythonCall.pybool</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pybool(x)</code></pre><p>Convert <code>x</code> to a Python <code>bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L529-L533">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycollist"><a class="docstring-binding" href="#PythonCall.pycollist"><code>PythonCall.pycollist</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycollist(x::AbstractArray)</code></pre><p>Create a nested Python <code>list</code>-of-<code>list</code>s from the elements of <code>x</code>. For matrices, this is a list of columns.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L902-L906">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pybytes"><a class="docstring-binding" href="#PythonCall.pybytes"><code>PythonCall.pybytes</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pybytes(x)</code></pre><p>Convert <code>x</code> to a Python <code>bytes</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L589-L593">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycomplex"><a class="docstring-binding" href="#PythonCall.pycomplex"><code>PythonCall.pycomplex</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycomplex(x=0.0)
pycomplex(re, im)</code></pre><p>Convert <code>x</code> to a Python <code>complex</code>, or create one from given real and imaginary parts.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L670-L675">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydict"><a class="docstring-binding" href="#PythonCall.pydict"><code>PythonCall.pydict</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydict(x)
pydict(; x...)
pydict(x::Pair...)</code></pre><p>Convert <code>x</code> to a Python <code>dict</code>. In the second form, the keys are strings.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>dict(x)</code> in Python. Otherwise <code>x</code> must iterate over key-value pairs.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L993-L1002">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyfloat"><a class="docstring-binding" href="#PythonCall.pyfloat"><code>PythonCall.pyfloat</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyfloat(x=0.0)</code></pre><p>Convert <code>x</code> to a Python <code>float</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L656-L660">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyfrozenset"><a class="docstring-binding" href="#PythonCall.pyfrozenset"><code>PythonCall.pyfrozenset</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyfrozenset(x=())</code></pre><p>Convert <code>x</code> to a Python <code>frozenset</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>frozenset(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L962-L969">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyint"><a class="docstring-binding" href="#PythonCall.pyint"><code>PythonCall.pyint</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyint(x=0)</code></pre><p>Convert <code>x</code> to a Python <code>int</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L629-L633">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pylist"><a class="docstring-binding" href="#PythonCall.pylist"><code>PythonCall.pylist</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pylist(x=())</code></pre><p>Convert <code>x</code> to a Python <code>list</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>list(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L891-L898">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyrange"><a class="docstring-binding" href="#PythonCall.pyrange"><code>PythonCall.pyrange</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyrange([[start], [stop]], [step])</code></pre><p>Construct a Python <code>range</code>. Unspecified arguments default to <code>None</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L791-L795">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyrowlist"><a class="docstring-binding" href="#PythonCall.pyrowlist"><code>PythonCall.pyrowlist</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyrowlist(x::AbstractArray)</code></pre><p>Create a nested Python <code>list</code>-of-<code>list</code>s from the elements of <code>x</code>. For matrices, this is a list of rows.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L920-L924">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyset"><a class="docstring-binding" href="#PythonCall.pyset"><code>PythonCall.pyset</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyset(x=())</code></pre><p>Convert <code>x</code> to a Python <code>set</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>set(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L951-L958">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyslice"><a class="docstring-binding" href="#PythonCall.pyslice"><code>PythonCall.pyslice</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyslice([start], stop, [step])</code></pre><p>Construct a Python <code>slice</code>. Unspecified arguments default to <code>None</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L778-L782">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pystr"><a class="docstring-binding" href="#PythonCall.pystr"><code>PythonCall.pystr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pystr(x)</code></pre><p>Convert <code>x</code> to a Python <code>str</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L557-L561">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pytuple"><a class="docstring-binding" href="#PythonCall.pytuple"><code>PythonCall.pytuple</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pytuple(x=())</code></pre><p>Convert <code>x</code> to a Python <code>tuple</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>tuple(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L846-L853">source</a></div></details></article><h2 id="Builtins"><a class="docs-heading-anchor" href="#Builtins">Builtins</a><a id="Builtins-1"></a><a class="docs-heading-anchor-permalink" href="#Builtins" title="Permalink"></a></h2><p>These functions mimic the Python builtin functions or keywords of the same name.</p><article><details class="docstring" open="true"><summary id="PythonCall.pyall"><a class="docstring-binding" href="#PythonCall.pyall"><code>PythonCall.pyall</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyall(x)</code></pre><p>Equivalent to <code>all(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1486-L1490">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyany"><a class="docstring-binding" href="#PythonCall.pyany"><code>PythonCall.pyany</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyany(x)</code></pre><p>Equivalent to <code>any(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1498-L1502">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyascii"><a class="docstring-binding" href="#PythonCall.pyascii"><code>PythonCall.pyascii</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyascii(x)</code></pre><p>Equivalent to <code>ascii(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L20-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycall"><a class="docstring-binding" href="#PythonCall.pycall"><code>PythonCall.pycall</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycall(f, args...; kwargs...)</code></pre><p>Call the Python object <code>f</code> with the given arguments.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L198-L202">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycallable"><a class="docstring-binding" href="#PythonCall.pycallable"><code>PythonCall.pycallable</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycallable(x)</code></pre><p>Equivalent to <code>callable(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1510-L1514">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycompile"><a class="docstring-binding" href="#PythonCall.pycompile"><code>PythonCall.pycompile</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycompile(...)</code></pre><p>Equivalent to <code>compile(...)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1522-L1526">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycontains"><a class="docstring-binding" href="#PythonCall.pycontains"><code>PythonCall.pycontains</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycontains(x, v)</code></pre><p>Equivalent to <code>v in x</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L280-L284">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydelattr"><a class="docstring-binding" href="#PythonCall.pydelattr"><code>PythonCall.pydelattr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydelattr(x, k)</code></pre><p>Equivalent to <code>delattr(x, k)</code> or <code>del x.k</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L80-L84">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydelitem"><a class="docstring-binding" href="#PythonCall.pydelitem"><code>PythonCall.pydelitem</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydelitem(x, k)</code></pre><p>Equivalent to <code>delitem(x, k)</code> or <code>del x[k]</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L179-L183">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydir"><a class="docstring-binding" href="#PythonCall.pydir"><code>PythonCall.pydir</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydir(x)</code></pre><p>Equivalent to <code>dir(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L186-L190">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyeval"><a class="docstring-binding" href="#PythonCall.pyeval"><code>PythonCall.pyeval</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyeval([T=Py], code, globals, locals=nothing)</code></pre><p>Evaluate the given Python <code>code</code>, returning the result as a <code>T</code>.</p><p>If <code>globals</code> is a <code>Module</code>, then a persistent <code>dict</code> unique to that module is used.</p><p>By default the code runs in global scope (i.e. <code>locals===globals</code>). To use a temporary local scope, set <code>locals</code> to <code>()</code>, or to a <code>NamedTuple</code> of variables to include in the scope.</p><p>See also <a href="#PythonCall.@pyeval"><code>@pyeval</code></a>.</p><p><strong>Examples</strong></p><p>The following computes <code>1.1+2.2</code> in the <code>Main</code> module as a <code>Float64</code>:</p><pre><code class="language-julia hljs">pyeval(Float64, &quot;x+y&quot;, Main, (x=1.1, y=2.2))  # returns 3.3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1139-L1158">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.@pyeval"><a class="docstring-binding" href="#PythonCall.@pyeval"><code>PythonCall.@pyeval</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@pyeval [inputs =&gt;] code [=&gt; T]</code></pre><p>Evaluate the given <code>code</code> in a new local scope and return the answer as a <code>T</code>.</p><p>The global scope is persistent and unique to the current module.</p><p>The <code>code</code> must be a literal string or command.</p><p>The <code>inputs</code> is a tuple of inputs of the form <code>v=expr</code> to be included in the local scope. Only <code>v</code> is required, <code>expr</code> defaults to <code>v</code>.</p><p><strong>Examples</strong></p><p>The following computes <code>1.1+2.2</code> and returns a <code>Float64</code>:</p><pre><code class="language-julia hljs">@pyeval (x=1.1, y=2.2) =&gt; `x+y` =&gt; Float64  # returns 3.3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1301-L1319">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyexec"><a class="docstring-binding" href="#PythonCall.pyexec"><code>PythonCall.pyexec</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyexec([T=Nothing], code, globals, locals=nothing)</code></pre><p>Execute the given Python <code>code</code>.</p><p>If <code>globals</code> is a <code>Module</code>, then a persistent <code>dict</code> unique to that module is used.</p><p>By default the code runs in global scope (i.e. <code>locals===globals</code>). To use a temporary local scope, set <code>locals</code> to <code>()</code>, or to a <code>NamedTuple</code> of variables to include in the scope.</p><p>If <code>T==Nothing</code> then returns <code>nothing</code>. Otherwise <code>T</code> must be a concrete <code>NamedTuple</code> type and the corresponding items from <code>locals</code> are extracted and returned.</p><p>See also <a href="#PythonCall.@pyexec"><code>@pyexec</code></a>.</p><p><strong>Examples</strong></p><p>The following computes <code>1.1+2.2</code> in the <code>Main</code> module as a <code>Float64</code>:</p><pre><code class="language-julia hljs">pyexec(@NamedTuple{ans::Float64}, &quot;ans=x+y&quot;, Main, (x=1.1, y=2.2))  # returns (ans = 3.3,)</code></pre><p>Marking variables as <code>global</code> saves them into the module scope, so that they are available in subsequent invocations:</p><pre><code class="language-julia hljs">pyexec(&quot;global x; x=12&quot;, Main)
pyeval(Int, &quot;x&quot;, Main)  # returns 12</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1195-L1224">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.@pyexec"><a class="docstring-binding" href="#PythonCall.@pyexec"><code>PythonCall.@pyexec</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@pyexec [inputs =&gt;] code [=&gt; outputs]</code></pre><p>Execute the given <code>code</code> in a new local scope.</p><p>The global scope is persistent and unique to the current module.</p><p>The <code>code</code> must be a literal string or command.</p><p>The <code>inputs</code> is a tuple of inputs of the form <code>v=expr</code> to be included in the local scope. Only <code>v</code> is required, <code>expr</code> defaults to <code>v</code>.</p><p>The <code>outputs</code> is a tuple of outputs of the form <code>x::T=v</code>, meaning that <code>v</code> is extracted from locals, converted to <code>T</code> and assigned to <code>x</code>. Only <code>x</code> is required: <code>T</code> defaults to <code>Py</code> and <code>v</code> defaults to <code>x</code>.</p><p><strong>Examples</strong></p><p>The following computes <code>1.1+2.2</code> and assigns its value to <code>ans</code> as a <code>Float64</code>:</p><pre><code class="language-julia hljs">@pyexec (x=1.1, y=2.2) =&gt; `ans=x+y` =&gt; ans::Float64  # returns 3.3</code></pre><p>Marking variables as <code>global</code> saves them into the module scope, so that they are available in subsequent invocations:</p><pre><code class="language-julia hljs">@pyexec `global x; x=12`
@pyeval `x` =&gt; Int  # returns 12</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1329-L1358">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pygetattr"><a class="docstring-binding" href="#PythonCall.pygetattr"><code>PythonCall.pygetattr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pygetattr(x, k, [d])</code></pre><p>Equivalent to <code>getattr(x, k)</code> or <code>x.k</code> in Python.</p><p>If <code>d</code> is specified, it is returned if the attribute does not exist.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L51-L57">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pygetitem"><a class="docstring-binding" href="#PythonCall.pygetitem"><code>PythonCall.pygetitem</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pygetitem(x, k, [d])</code></pre><p>Equivalent <code>x[k]</code> in Python.</p><p>If <code>d</code> is specified, it is returned if the item does not exist (i.e. if <code>x[k]</code> raises a <code>KeyError</code> or <code>IndexError</code>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L149-L156">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyhasattr"><a class="docstring-binding" href="#PythonCall.pyhasattr"><code>PythonCall.pyhasattr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyhasattr(x, k)</code></pre><p>Equivalent to <code>hasattr(x, k)</code> in Python.</p><p>Tests if <code>getattr(x, k)</code> raises an <code>AttributeError</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L28-L34">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyhasitem"><a class="docstring-binding" href="#PythonCall.pyhasitem"><code>PythonCall.pyhasitem</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyhasitem(x, k)</code></pre><p>Test if <code>pygetitem(x, k)</code> raises a <code>KeyError</code> or <code>AttributeError</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L129-L133">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyhash"><a class="docstring-binding" href="#PythonCall.pyhash"><code>PythonCall.pyhash</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyhash(x)</code></pre><p>Equivalent to <code>hash(x)</code> in Python, converted to an <code>Integer</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L101-L105">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyhelp"><a class="docstring-binding" href="#PythonCall.pyhelp"><code>PythonCall.pyhelp</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyhelp([x])</code></pre><p>Equivalent to <code>help(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1478-L1482">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyimport"><a class="docstring-binding" href="#PythonCall.pyimport"><code>PythonCall.pyimport</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyimport(m)
pyimport(m =&gt; k)
pyimport(m =&gt; (k1, k2, ...))
pyimport(m1, m2, ...)</code></pre><p>Import a module <code>m</code>, or an attribute <code>k</code>, or a tuple of attributes.</p><p>If several arguments are given, return the results of importing each one in a tuple.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1448-L1457">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyin"><a class="docstring-binding" href="#PythonCall.pyin"><code>PythonCall.pyin</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyin(v, x)</code></pre><p>Equivalent to <code>v in x</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L287-L291">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyis"><a class="docstring-binding" href="#PythonCall.pyis"><code>PythonCall.pyis</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyis(x, y)</code></pre><p>True if <code>x</code> and <code>y</code> are the same Python object. Equivalent to <code>x is y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L3-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyisinstance"><a class="docstring-binding" href="#PythonCall.pyisinstance"><code>PythonCall.pyisinstance</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyisinstance(x, t)</code></pre><p>Test if <code>x</code> is of type <code>t</code>. Equivalent to <code>isinstance(x, t)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L94-L98">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyissubclass"><a class="docstring-binding" href="#PythonCall.pyissubclass"><code>PythonCall.pyissubclass</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyissubclass(s, t)</code></pre><p>Test if <code>s</code> is a subclass of <code>t</code>. Equivalent to <code>issubclass(s, t)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L87-L91">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyiter"><a class="docstring-binding" href="#PythonCall.pyiter"><code>PythonCall.pyiter</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyiter(x)</code></pre><p>Equivalent to <code>iter(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L502-L506">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pylen"><a class="docstring-binding" href="#PythonCall.pylen"><code>PythonCall.pylen</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pylen(x)</code></pre><p>The length of <code>x</code>. Equivalent to <code>len(x)</code> in Python, converted to an <code>Integer</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L122-L126">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pynext"><a class="docstring-binding" href="#PythonCall.pynext"><code>PythonCall.pynext</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pynext(x)</code></pre><p>Equivalent to <code>next(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L509-L513">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyprint"><a class="docstring-binding" href="#PythonCall.pyprint"><code>PythonCall.pyprint</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyprint(...)</code></pre><p>Equivalent to <code>print(...)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1466-L1470">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyrepr"><a class="docstring-binding" href="#PythonCall.pyrepr"><code>PythonCall.pyrepr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyrepr(x)</code></pre><p>Equivalent to <code>repr(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L12-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pysetattr"><a class="docstring-binding" href="#PythonCall.pysetattr"><code>PythonCall.pysetattr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pysetattr(x, k, v)</code></pre><p>Equivalent to <code>setattr(x, k, v)</code> or <code>x.k = v</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L73-L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pysetitem"><a class="docstring-binding" href="#PythonCall.pysetitem"><code>PythonCall.pysetitem</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pysetitem(x, k, v)</code></pre><p>Equivalent to <code>setitem(x, k, v)</code> or <code>x[k] = v</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L172-L176">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pytype-Tuple{Any}"><a class="docstring-binding" href="#PythonCall.pytype-Tuple{Any}"><code>PythonCall.pytype</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pytype(x)</code></pre><p>The Python <code>type</code> of <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L691-L695">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pywith"><a class="docstring-binding" href="#PythonCall.pywith"><code>PythonCall.pywith</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pywith(f, o, d=nothing)</code></pre><p>Equivalent to <code>with o as x: f(x)</code> in Python, where <code>x</code> is a <code>Py</code>.</p><p>On success, the value of <code>f(x)</code> is returned.</p><p>If an exception occurs but is suppressed then <code>d</code> is returned.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L1416-L1424">source</a></div></details></article><h2 id="Conversion-to-Julia"><a class="docs-heading-anchor" href="#Conversion-to-Julia">Conversion to Julia</a><a id="Conversion-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-to-Julia" title="Permalink"></a></h2><p>These functions convert Python values to Julia values, using the rules documented <a href="../conversion-to-python/#jl2py">here</a>.</p><article><details class="docstring" open="true"><summary id="PythonCall.pyconvert"><a class="docstring-binding" href="#PythonCall.pyconvert"><code>PythonCall.pyconvert</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyconvert(T, x, [d])</code></pre><p>Convert the Python object <code>x</code> to a <code>T</code>.</p><p>If <code>d</code> is specified, it is returned on failure instead of throwing an error.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Convert/pyconvert.jl#L383-L389">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.@pyconvert"><a class="docstring-binding" href="#PythonCall.@pyconvert"><code>PythonCall.@pyconvert</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@pyconvert(T, x, [onfail])</code></pre><p>Convert the Python object <code>x</code> to a <code>T</code>.</p><p>On failure, evaluates to <code>onfail</code>, which defaults to <code>return pyconvert_unconverted()</code> (mainly useful for writing conversion rules).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Convert/pyconvert.jl#L363-L369">source</a></div></details></article><h2 id="Wrap-Julia-values"><a class="docs-heading-anchor" href="#Wrap-Julia-values">Wrap Julia values</a><a id="Wrap-Julia-values-1"></a><a class="docs-heading-anchor-permalink" href="#Wrap-Julia-values" title="Permalink"></a></h2><p>These functions explicitly wrap Julia values into Python objects, documented <a href="../juliacall-reference/#julia-wrappers">here</a>.</p><p>As documented <a href="../conversion-to-julia/#py2jl">here</a>, Julia values are wrapped like this automatically on conversion to Python, unless the value is immutable and has a corresponding Python type.</p><article><details class="docstring" open="true"><summary id="PythonCall.pyjl"><a class="docstring-binding" href="#PythonCall.pyjl"><code>PythonCall.pyjl</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyjl([t=pyjltype(x)], x)</code></pre><p>Create a Python object wrapping the Julia object <code>x</code>.</p><p>If <code>x</code> is mutable, then mutating the returned object also mutates <code>x</code>, and vice versa.</p><p>Its Python type is normally inferred from the type of <code>x</code>, but can be specified with <code>t</code>.</p><p>For example if <code>x</code> is an <code>AbstractVector</code> then the object will have type <code>juliacall.VectorValue</code>. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.</p><p>To define a custom conversion for your type <code>T</code>, overload <code>pyjltype(::T)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/any.jl#L386-L399">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyjlraw"><a class="docstring-binding" href="#PythonCall.pyjlraw"><code>PythonCall.pyjlraw</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyjlraw(v)</code></pre><p>Create a Python object wrapping the Julia object <code>x</code>.</p><p>It has type <code>juliacall.RawValue</code>. This has a much more rigid &quot;Julian&quot; interface than <code>pyjl(v)</code>. For example, accessing attributes or calling this object will always return a <code>RawValue</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/raw.jl#L166-L173">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyisjl"><a class="docstring-binding" href="#PythonCall.pyisjl"><code>PythonCall.pyisjl</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyisjl(x)</code></pre><p>Test whether <code>x</code> is a wrapped Julia value, namely an instance of <code>juliacall.ValueBase</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/base.jl#L9-L13">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyjlvalue"><a class="docstring-binding" href="#PythonCall.pyjlvalue"><code>PythonCall.pyjlvalue</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyjlvalue(x)</code></pre><p>Extract the value from the wrapped Julia value <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/base.jl#L24-L28">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pybinaryio"><a class="docstring-binding" href="#PythonCall.pybinaryio"><code>PythonCall.pybinaryio</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pybinaryio(io::IO)</code></pre><p>Wrap <code>io</code> as a Python binary IO object.</p><p>This is the default behaviour of <code>Py(io)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/io.jl#L332-L338">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pytextio"><a class="docstring-binding" href="#PythonCall.pytextio"><code>PythonCall.pytextio</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pytextio(io::IO)</code></pre><p>Wrap <code>io</code> as a Python text IO object.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/io.jl#L341-L345">source</a></div></details></article><h2 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h2><p>These functions are equivalent to the corresponding Python arithmetic operators.</p><p>Note that the equivalent Julia operators are overloaded to call these when all arguments are <code>Py</code> (or <code>Number</code>). Hence the following are equivalent: <code>Py(1)+Py(2)</code>, <code>Py(1)+2</code>, <code>pyadd(1, 2)</code>, <code>pyadd(Py(1), Py(2))</code>, etc.</p><article><details class="docstring" open="true"><summary id="PythonCall.pyneg"><a class="docstring-binding" href="#PythonCall.pyneg"><code>PythonCall.pyneg</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyneg(x)</code></pre><p>Equivalent to <code>-x</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L299-L303">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pypos"><a class="docstring-binding" href="#PythonCall.pypos"><code>PythonCall.pypos</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pypos(x)</code></pre><p>Equivalent to <code>+x</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L305-L309">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyabs"><a class="docstring-binding" href="#PythonCall.pyabs"><code>PythonCall.pyabs</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyabs(x)</code></pre><p>Equivalent to <code>abs(x)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L311-L315">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyinv"><a class="docstring-binding" href="#PythonCall.pyinv"><code>PythonCall.pyinv</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyinv(x)</code></pre><p>Equivalent to <code>~x</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L317-L321">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyindex"><a class="docstring-binding" href="#PythonCall.pyindex"><code>PythonCall.pyindex</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyindex(x)</code></pre><p>Convert <code>x</code> losslessly to an <code>int</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L323-L327">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyadd"><a class="docstring-binding" href="#PythonCall.pyadd"><code>PythonCall.pyadd</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyadd(x, y)</code></pre><p>Equivalent to <code>x + y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L331-L335">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pysub"><a class="docstring-binding" href="#PythonCall.pysub"><code>PythonCall.pysub</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pysub(x, y)</code></pre><p>Equivalent to <code>x - y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L337-L341">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pymul"><a class="docstring-binding" href="#PythonCall.pymul"><code>PythonCall.pymul</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pymul(x, y)</code></pre><p>Equivalent to <code>x * y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L343-L347">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pymatmul"><a class="docstring-binding" href="#PythonCall.pymatmul"><code>PythonCall.pymatmul</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pymatmul(x, y)</code></pre><p>Equivalent to <code>x @ y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L349-L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pypow"><a class="docstring-binding" href="#PythonCall.pypow"><code>PythonCall.pypow</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pypow(x, y, z=None)</code></pre><p>Equivalent to <code>x ** y</code> or <code>pow(x, y, z)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L485-L489">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyfloordiv"><a class="docstring-binding" href="#PythonCall.pyfloordiv"><code>PythonCall.pyfloordiv</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyfloordiv(x, y)</code></pre><p>Equivalent to <code>x // y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L355-L359">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pytruediv"><a class="docstring-binding" href="#PythonCall.pytruediv"><code>PythonCall.pytruediv</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pytruediv(x, y)</code></pre><p>Equivalent to <code>x / y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L361-L365">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pymod"><a class="docstring-binding" href="#PythonCall.pymod"><code>PythonCall.pymod</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pymod(x, y)</code></pre><p>Equivalent to <code>x % y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L367-L371">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydivmod"><a class="docstring-binding" href="#PythonCall.pydivmod"><code>PythonCall.pydivmod</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydivmod(x, y)</code></pre><p>Equivalent to <code>divmod(x, y)</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L373-L377">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pylshift"><a class="docstring-binding" href="#PythonCall.pylshift"><code>PythonCall.pylshift</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pylshift(x, y)</code></pre><p>Equivalent to <code>x &lt;&lt; y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L379-L383">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyrshift"><a class="docstring-binding" href="#PythonCall.pyrshift"><code>PythonCall.pyrshift</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyrshift(x, y)</code></pre><p>Equivalent to <code>x &gt;&gt; y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L385-L389">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyand"><a class="docstring-binding" href="#PythonCall.pyand"><code>PythonCall.pyand</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyand(x, y)</code></pre><p>Equivalent to <code>x &amp; y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L391-L395">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyxor"><a class="docstring-binding" href="#PythonCall.pyxor"><code>PythonCall.pyxor</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyxor(x, y)</code></pre><p>Equivalent to <code>x ^ y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L397-L401">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyor"><a class="docstring-binding" href="#PythonCall.pyor"><code>PythonCall.pyor</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyor(x, y)</code></pre><p>Equivalent to <code>x | y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L403-L407">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyiadd"><a class="docstring-binding" href="#PythonCall.pyiadd"><code>PythonCall.pyiadd</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyiadd(x, y)</code></pre><p>In-place add. <code>x = pyiadd(x, y)</code> is equivalent to <code>x += y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L411-L415">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyisub"><a class="docstring-binding" href="#PythonCall.pyisub"><code>PythonCall.pyisub</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyisub(x, y)</code></pre><p>In-place subtract. <code>x = pyisub(x, y)</code> is equivalent to <code>x -= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L417-L421">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyimul"><a class="docstring-binding" href="#PythonCall.pyimul"><code>PythonCall.pyimul</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyimul(x, y)</code></pre><p>In-place multiply. <code>x = pyimul(x, y)</code> is equivalent to <code>x *= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L423-L427">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyimatmul"><a class="docstring-binding" href="#PythonCall.pyimatmul"><code>PythonCall.pyimatmul</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyimatmul(x, y)</code></pre><p>In-place matrix multiply. <code>x = pyimatmul(x, y)</code> is equivalent to <code>x @= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L429-L433">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyipow"><a class="docstring-binding" href="#PythonCall.pyipow"><code>PythonCall.pyipow</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyipow(x, y, z=None)</code></pre><p>In-place power. <code>x = pyipow(x, y)</code> is equivalent to <code>x **= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L492-L496">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyifloordiv"><a class="docstring-binding" href="#PythonCall.pyifloordiv"><code>PythonCall.pyifloordiv</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyifloordiv(x, y)</code></pre><p>In-place floor divide. <code>x = pyifloordiv(x, y)</code> is equivalent to <code>x //= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L435-L439">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyitruediv"><a class="docstring-binding" href="#PythonCall.pyitruediv"><code>PythonCall.pyitruediv</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyitruediv(x, y)</code></pre><p>In-place true division. <code>x = pyitruediv(x, y)</code> is equivalent to <code>x /= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L441-L445">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyimod"><a class="docstring-binding" href="#PythonCall.pyimod"><code>PythonCall.pyimod</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyimod(x, y)</code></pre><p>In-place subtraction. <code>x = pyimod(x, y)</code> is equivalent to <code>x %= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L447-L451">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyilshift"><a class="docstring-binding" href="#PythonCall.pyilshift"><code>PythonCall.pyilshift</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyilshift(x, y)</code></pre><p>In-place left shift. <code>x = pyilshift(x, y)</code> is equivalent to <code>x &lt;&lt;= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L453-L457">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyirshift"><a class="docstring-binding" href="#PythonCall.pyirshift"><code>PythonCall.pyirshift</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyirshift(x, y)</code></pre><p>In-place right shift. <code>x = pyirshift(x, y)</code> is equivalent to <code>x &gt;&gt;= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L459-L463">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyiand"><a class="docstring-binding" href="#PythonCall.pyiand"><code>PythonCall.pyiand</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyiand(x, y)</code></pre><p>In-place and. <code>x = pyiand(x, y)</code> is equivalent to <code>x &amp;= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L465-L469">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyixor"><a class="docstring-binding" href="#PythonCall.pyixor"><code>PythonCall.pyixor</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyixor(x, y)</code></pre><p>In-place xor. <code>x = pyixor(x, y)</code> is equivalent to <code>x ^= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L471-L475">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyior"><a class="docstring-binding" href="#PythonCall.pyior"><code>PythonCall.pyior</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyior(x, y)</code></pre><p>In-place or. <code>x = pyior(x, y)</code> is equivalent to <code>x |= y</code> in Python.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L477-L481">source</a></div></details></article><h2 id="Logic"><a class="docs-heading-anchor" href="#Logic">Logic</a><a id="Logic-1"></a><a class="docs-heading-anchor-permalink" href="#Logic" title="Permalink"></a></h2><p>These functions are equivalent to the corresponding Python logical operators.</p><p>Note that the equivalent Julia operators are overloaded to call these when all arguments are <code>Py</code> (or <code>Number</code>). Hence the following are equivalent: <code>Py(1) &lt; Py(2)</code>, <code>Py(1) &lt; 2</code>, <code>pylt(1, 2)</code>, <code>pylt(Py(1), Py(2))</code>, etc.</p><p>Note that the binary operators by default return <code>Py</code> (not <code>Bool</code>) since comparisons in Python do not necessarily return <code>bool</code>.</p><article><details class="docstring" open="true"><summary id="PythonCall.pytruth"><a class="docstring-binding" href="#PythonCall.pytruth"><code>PythonCall.pytruth</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pytruth(x)</code></pre><p>The truthyness of <code>x</code>. Equivalent to <code>bool(x)</code> in Python, converted to a <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L108-L112">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pynot"><a class="docstring-binding" href="#PythonCall.pynot"><code>PythonCall.pynot</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pynot(x)</code></pre><p>The falsyness of <code>x</code>. Equivalent to <code>not x</code> in Python, converted to a <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L115-L119">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyeq"><a class="docstring-binding" href="#PythonCall.pyeq"><code>PythonCall.pyeq</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyeq(x, y)
pyeq(Bool, x, y)</code></pre><p>Equivalent to <code>x == y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L220-L225">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyne"><a class="docstring-binding" href="#PythonCall.pyne"><code>PythonCall.pyne</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyne(x, y)
pyne(Bool, x, y)</code></pre><p>Equivalent to <code>x != y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L228-L233">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyle"><a class="docstring-binding" href="#PythonCall.pyle"><code>PythonCall.pyle</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyle(x, y)
pyle(Bool, x, y)</code></pre><p>Equivalent to <code>x &lt;= y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L236-L241">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pylt"><a class="docstring-binding" href="#PythonCall.pylt"><code>PythonCall.pylt</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pylt(x, y)
pylt(Bool, x, y)</code></pre><p>Equivalent to <code>x &lt; y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L244-L249">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyge"><a class="docstring-binding" href="#PythonCall.pyge"><code>PythonCall.pyge</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyge(x, y)
pyge(Bool, x, y)</code></pre><p>Equivalent to <code>x &gt;= y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L252-L257">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pygt"><a class="docstring-binding" href="#PythonCall.pygt"><code>PythonCall.pygt</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pygt(x, y)
pygt(Bool, x, y)</code></pre><p>Equivalent to <code>x &gt; y</code> in Python. The second form converts to <code>Bool</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L260-L265">source</a></div></details></article><h2 id="Create-classes"><a class="docs-heading-anchor" href="#Create-classes">Create classes</a><a id="Create-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Create-classes" title="Permalink"></a></h2><p>These functions can be used to create new Python classes where the functions are implemented in Julia. You can instead use <a href="#PythonCall.@pyeval"><code>@pyeval</code></a> etc. to create pure-Python classes.</p><article><details class="docstring" open="true"><summary id="PythonCall.pytype-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PythonCall.pytype-Tuple{Any, Any, Any}"><code>PythonCall.pytype</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pytype(name, bases, dict)</code></pre><p>Create a new type. Equivalent to <code>type(name, bases, dict)</code> in Python.</p><p>If <code>bases</code> is not a Python object, it is converted to one using <code>pytuple</code>.</p><p>The <code>dict</code> may either by a Python object or a Julia iterable. In the latter case, each item may either be a <code>name =&gt; value</code> pair or a Python object with a <code>__name__</code> attribute.</p><p>In order to use a Julia <code>Function</code> as an instance method, it must be wrapped into a Python function with <a href="#PythonCall.pyfunc"><code>pyfunc</code></a>. Similarly, see also <a href="#PythonCall.pyclassmethod"><code>pyclassmethod</code></a>, <a href="#PythonCall.pystaticmethod"><code>pystaticmethod</code></a> or <a href="#PythonCall.pyproperty"><code>pyproperty</code></a>. In all these cases, the arguments passed to the function always have type <code>Py</code>. See the example below.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Foo = pytype(&quot;Foo&quot;, (), [
    &quot;__module__&quot; =&gt; &quot;__main__&quot;,

    pyfunc(
        name = &quot;__init__&quot;,
        doc = &quot;&quot;&quot;
        Specify x and y to store in the Foo.

        If omitted, y defaults to None.
        &quot;&quot;&quot;,
        function (self, x, y = nothing)
            self.x = x
            self.y = y
            return
        end,
    ),

    pyfunc(
        name = &quot;__repr__&quot;,
        self -&gt; &quot;Foo($(self.x), $(self.y))&quot;,
    ),

    pyclassmethod(
        name = &quot;frompair&quot;,
        doc = &quot;Construct a Foo from a tuple of length two.&quot;,
        (cls, xy) -&gt; cls(xy...),
    ),

    pystaticmethod(
        name = &quot;hello&quot;,
        doc = &quot;Prints a friendly greeting.&quot;,
        (name) -&gt; println(&quot;Hello, $name&quot;),
    ),

    &quot;xy&quot; =&gt; pyproperty(
        doc = &quot;A tuple of x and y.&quot;,
        get = (self) -&gt; (self.x, self.y),
        set = function (self, xy)
            (x, y) = xy
            self.x = x
            self.y = y
            nothing
        end,
    ),
])</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L698-L762">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyfunc"><a class="docstring-binding" href="#PythonCall.pyfunc"><code>PythonCall.pyfunc</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyfunc(f; [name], [qualname], [doc], [signature])</code></pre><p>Wrap the callable <code>f</code> as an ordinary Python function.</p><p>The name, qualname, docstring or signature can optionally be set with <code>name</code>, <code>qualname</code>, <code>doc</code> or <code>signature</code>.</p><p>Unlike <code>Py(f)</code> (or <code>pyjl(f)</code>), the arguments passed to <code>f</code> are always of type <code>Py</code>, i.e. they are never converted.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/callback.jl#L74-L84">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyclassmethod"><a class="docstring-binding" href="#PythonCall.pyclassmethod"><code>PythonCall.pyclassmethod</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyclassmethod(f; ...)</code></pre><p>Convert callable <code>f</code> to a Python class method.</p><p>If <code>f</code> is not a Python object (e.g. if <code>f</code> is a <code>Function</code>) then it is converted to one with <a href="#PythonCall.pyfunc"><code>pyfunc</code></a>. In particular this means the arguments passed to <code>f</code> are always of type <code>Py</code>. Keyword arguments are passed to <code>pyfunc</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/callback.jl#L115-L123">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pystaticmethod"><a class="docstring-binding" href="#PythonCall.pystaticmethod"><code>PythonCall.pystaticmethod</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pystaticmethod(f; ...)</code></pre><p>Convert callable <code>f</code> to a Python static method.</p><p>If <code>f</code> is not a Python object (e.g. if <code>f</code> is a <code>Function</code>) then it is converted to one with <a href="#PythonCall.pyfunc"><code>pyfunc</code></a>. In particular this means the arguments passed to <code>f</code> are always of type <code>Py</code>. Any keyword arguments are passed to <code>pyfunc</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/callback.jl#L126-L134">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyproperty"><a class="docstring-binding" href="#PythonCall.pyproperty"><code>PythonCall.pyproperty</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyproperty(; get=nothing, set=nothing, del=nothing, doc=nothing)
pyproperty(get)</code></pre><p>Create a Python <code>property</code> with the given getter, setter and deleter.</p><p>If <code>get</code>, <code>set</code> or <code>del</code> is not a Python object (e.g. if it is a <code>Function</code>) then it is converted to one with <a href="#PythonCall.pyfunc"><code>pyfunc</code></a>. In particular this means the arguments passed to it are always of type <code>Py</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/JlWrap/callback.jl#L137-L146">source</a></div></details></article><h2 id="python-wrappers"><a class="docs-heading-anchor" href="#python-wrappers">Wrapper types</a><a id="python-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#python-wrappers" title="Permalink"></a></h2><p>The following types wrap a Python object, giving it the semantics of a Julia object. For example <code>PyList(x)</code> interprets the Python sequence <code>x</code> as a Julia abstract vector.</p><p>Apart from a few fundamental immutable types, conversion from Python to Julia <code>Any</code> will return a wrapper type such as one of these, or simply <code>Py</code> if no wrapper type is suitable.</p><article><details class="docstring" open="true"><summary id="PythonCall.PyList"><a class="docstring-binding" href="#PythonCall.PyList"><code>PythonCall.PyList</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyList{T=Py}([x])</code></pre><p>Wraps the Python list <code>x</code> (or anything satisfying the sequence interface) as an <code>AbstractVector{T}</code>.</p><p>If <code>x</code> is not a Python object, it is converted to one using <code>pylist</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L172-L178">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PySet"><a class="docstring-binding" href="#PythonCall.PySet"><code>PythonCall.PySet</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PySet{T=Py}([x])</code></pre><p>Wraps the Python set <code>x</code> (or anything satisfying the set interface) as an <code>AbstractSet{T}</code>.</p><p>If <code>x</code> is not a Python object, it is converted to one using <code>pyset</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L220-L226">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyDict"><a class="docstring-binding" href="#PythonCall.PyDict"><code>PythonCall.PyDict</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyDict{K=Py,V=Py}([x])</code></pre><p>Wraps the Python dict <code>x</code> (or anything satisfying the mapping interface) as an <code>AbstractDict{K,V}</code>.</p><p>If <code>x</code> is not a Python object, it is converted to one using <code>pydict</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L93-L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyIterable"><a class="docstring-binding" href="#PythonCall.PyIterable"><code>PythonCall.PyIterable</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyIterable{T=Py}(x)</code></pre><p>This object iterates over iterable Python object <code>x</code>, yielding values of type <code>T</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L162-L166">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyArray"><a class="docstring-binding" href="#PythonCall.PyArray"><code>PythonCall.PyArray</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyArray{T,N,M,L,R}(x; copy=true, array=true, buffer=true)</code></pre><p>Wrap the Python array <code>x</code> as a Julia <code>AbstractArray{T,N}</code>.</p><p>The input <code>x</code> can be <code>bytes</code>, <code>bytearray</code>, <code>array.array</code>, <code>numpy.ndarray</code> or anything satisfying the buffer protocol (if <code>buffer=true</code>) or the numpy array interface (if <code>array=true</code>).</p><p>If <code>copy=false</code> then the resulting array is guaranteed to directly wrap the data in <code>x</code>. If <code>copy=true</code> then a copy is taken if necessary to produce an array.</p><p>The type parameters are all optional, and are:</p><ul><li><code>T</code>: The element type.</li><li><code>N</code>: The number of dimensions.</li><li><code>M</code>: True if the array is mutable.</li><li><code>L</code>: True if the array supports fast linear indexing.</li><li><code>R</code>: The element type of the underlying buffer. Often equal to <code>T</code>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L53-L68">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyIO"><a class="docstring-binding" href="#PythonCall.PyIO"><code>PythonCall.PyIO</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyIO(x; own=false, text=missing, line_buffering=false, buflen=4096)</code></pre><p>Wrap the Python IO stream <code>x</code> as a Julia IO stream.</p><p>When this goes out of scope and is finalized, it is automatically flushed. If <code>own=true</code> then it is also closed.</p><p>If <code>text=false</code> then <code>x</code> must be a binary stream and arbitrary binary I/O is possible. If <code>text=true</code> then <code>x</code> must be a text stream and only UTF-8 must be written (i.e. use <code>print</code> not <code>write</code>). If <code>text</code> is not specified then it is chosen automatically. If <code>x</code> is a text stream and you really need a binary stream, then often <code>PyIO(x.buffer)</code> will work.</p><p>If <code>line_buffering=true</code> then output is flushed at each line.</p><p>For efficiency, reads and writes are buffered before being sent to <code>x</code>. The size of the buffers is <code>buflen</code>. The buffers are cleared using <code>flush</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L105-L122">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyTable"><a class="docstring-binding" href="#PythonCall.PyTable"><code>PythonCall.PyTable</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyTable(x)</code></pre><p>Wrap <code>x</code> as a Tables.jl-compatible table.</p><p><code>PyTable</code> is an abstract type. See <a href="#PythonCall.PyPandasDataFrame"><code>PyPandasDataFrame</code></a> for a concrete example.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L184-L190">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyPandasDataFrame"><a class="docstring-binding" href="#PythonCall.PyPandasDataFrame"><code>PythonCall.PyPandasDataFrame</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyPandasDataFrame(x; [indexname::Union{Nothing,Symbol}], [columnnames::Function], [columntypes::Function])</code></pre><p>Wraps the pandas DataFrame <code>x</code> as a Tables.jl-compatible table.</p><ul><li><code>indexname</code>: The name of the column including the index. The default is <code>nothing</code>, meaning to exclude the index.</li><li><code>columnnames</code>: A function mapping the Python column name (a <code>Py</code>) to the Julia one (a <code>Symbol</code>). The default is <code>x -&gt; Symbol(x)</code>.</li><li><code>columntypes</code>: A function taking the column name (a <code>Symbol</code>) and returning either the desired element type of the column, or <code>nothing</code> to indicate automatic inference.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L193-L204">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyObjectArray"><a class="docstring-binding" href="#PythonCall.PyObjectArray"><code>PythonCall.PyObjectArray</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyObjectArray(undef, dims...)
PyObjectArray(array)</code></pre><p>An array of <code>Py</code>s which supports the Python buffer protocol.</p><p>Internally, the objects are stored as an array of pointers.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L232-L239">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.PyException"><a class="docstring-binding" href="#PythonCall.PyException"><code>PythonCall.PyException</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PyException(x)</code></pre><p>Wraps the Python exception <code>x</code> as a Julia <code>Exception</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/API/types.jl#L30-L34">source</a></div></details></article><h3 id="python-wrappers-custom"><a class="docs-heading-anchor" href="#python-wrappers-custom">Custom wrappers</a><a id="python-wrappers-custom-1"></a><a class="docs-heading-anchor-permalink" href="#python-wrappers-custom" title="Permalink"></a></h3><p>Here is a minimal example of defining a wrapper type. You may add methods, fields and a supertype to the type to specialise its behaviour. See any of the above wrapper types for examples.</p><pre><code class="language-julia hljs"># The new type with a field for the Python object being wrapped.
struct MyType
    py::Py
end

# Says that the object is a wrapper.
ispy(x::MyType) = true

# Says how to access the underlying Python object.
Py(x::MyType) = x.py</code></pre><h2 id="@py-and-@pyconst"><a class="docs-heading-anchor" href="#@py-and-@pyconst"><code>@py</code> and <code>@pyconst</code></a><a id="@py-and-@pyconst-1"></a><a class="docs-heading-anchor-permalink" href="#@py-and-@pyconst" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PythonCall.@py"><a class="docstring-binding" href="#PythonCall.@py"><code>PythonCall.@py</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@py expr</code></pre><p>Evaluate <code>expr</code> using Python-like syntax and semantics and return the resulting <a href="#PythonCall.Py"><code>Py</code></a> object.</p><p>Supported syntax includes:</p><ul><li><strong>Literals and names:</strong> Numeric and string literals, <code>None</code>, <code>True</code>, <code>False</code>, containers (<code>(…)</code>, <code>[…]</code>, <code>{…}</code>, <code>{key:value, …}</code>) and special placeholders such as <code>__file__</code> and <code>__line__</code>.</li><li><strong>Calls and operators:</strong> Function calls are translated to <code>pycall</code>, unary and binary operators are forwarded to the corresponding <code>py*</code> helper (e.g. <code>x + y</code> → <code>pyadd(x, y)</code>, <code>x === y</code> → <code>pyis(x, y)</code>), and chained arithmetic or comparison expressions behave like their Python equivalents.</li><li><strong>Attribute access and indexing:</strong> <code>obj.attr</code>, <code>obj[key]</code>, and slice syntax (<code>obj[start:stop:step]</code>) map to <code>pygetattr</code>, <code>pygetitem</code>, and <code>pyslice</code>.</li><li><strong>Statements:</strong> Assignments, <code>@del</code> deletions, <code>if</code>/<code>elseif</code>/<code>else</code>, <code>while</code>, <code>for</code>, short-circuit boolean logic (<code>&amp;&amp;</code>/<code>||</code>). Import statements (<code>import pkg</code>, <code>import pkg as alias</code>, <code>import pkg: attr as alias</code>) are also supported.</li><li><strong>Interop helpers:</strong> Use <code>@jl expr</code> to splice the result of a Julia expression into the Python evaluation. The auxiliary macros <code>@compile</code>, <code>@eval</code>, and <code>@exec</code> work like <code>compile</code>/<code>eval</code>/<code>exec</code> in Python but compile the code argument once and reuse it for speed.</li></ul><p>Names that match Python builtins are resolved through <a href="#PythonCall.pybuiltins"><code>pybuiltins</code></a>; other identifiers are captured from the surrounding Julia scope.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @py begin
           import math: sqrt
           sqrt(9)
       end
Py(3.0)

julia&gt; factor = 10
julia&gt; @py begin
           data = [1, 2, @jl factor]
           total = 0
           for value in data
               total = total + value
           end
           total
       end
Py(13)

julia&gt; @py begin
           info = {&quot;x&quot;: 1, &quot;y&quot;: 2}
           @del info[&quot;x&quot;]
           info
       end
Py({&#39;y&#39;: 2})</code></pre><div class="admonition is-warning" id="Warning-da4d0b9a00010955"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-da4d0b9a00010955" title="Permalink"></a></header><div class="admonition-body"><p>This macro is experimental. It may be modified or removed in a future release.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/PyMacro/PyMacro.jl#L860-L919">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.@pyconst"><a class="docstring-binding" href="#PythonCall.@pyconst"><code>PythonCall.@pyconst</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@pyconst ex</code></pre><p>Equivalent to <code>Py(ex)</code> but always returns the exact same Julia object.</p><p>That is, if <code>foo() = @pyconst ex</code> then <code>foo() === foo()</code>.</p><p>The expression <code>ex</code> is evaluated the first time the code is run.</p><p>If <code>ex</code> is a string literal, the string is interned.</p><p>Do not use this macro at the top level of a module. Instead, use <code>pynew()</code> and <code>pycopy!()</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/pyconst_macro.jl#L1-L13">source</a></div></details></article><h2 id="Multi-threading"><a class="docs-heading-anchor" href="#Multi-threading">Multi-threading</a><a id="Multi-threading-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threading" title="Permalink"></a></h2><p>These functions are not exported. They support multi-threading of Python and/or Julia. See also <a href="../juliacall-reference/#julia-wrappers"><code>juliacall.AnyValue._jl_call_nogil</code></a>.</p><article><details class="docstring" open="true"><summary id="PythonCall.GIL.lock"><a class="docstring-binding" href="#PythonCall.GIL.lock"><code>PythonCall.GIL.lock</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">lock(f)</code></pre><p>Lock the GIL, compute <code>f()</code>, unlock the GIL, then return the result of <code>f()</code>.</p><p>Use this to run Python code from threads that do not currently hold the GIL, such as new threads. Since the main Julia thread holds the GIL by default, you will need to <a href="#PythonCall.GIL.unlock"><code>unlock</code></a> the GIL before using this function.</p><p>See <a href="#PythonCall.GIL.@lock"><code>@lock</code></a> for the macro form.</p><div class="admonition is-warning" id="Warning-434658bd2e2cf008"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-434658bd2e2cf008" title="Permalink"></a></header><div class="admonition-body"><p>This function is experimental. Its semantics may be changed without notice.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/GIL/GIL.jl#L29-L43">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.GIL.@lock"><a class="docstring-binding" href="#PythonCall.GIL.@lock"><code>PythonCall.GIL.@lock</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@lock expr</code></pre><p>Lock the GIL, compute <code>expr</code>, unlock the GIL, then return the result of <code>expr</code>.</p><p>Use this to run Python code from threads that do not currently hold the GIL, such as new threads. Since the main Julia thread holds the GIL by default, you will need to <a href="#PythonCall.GIL.@unlock"><code>@unlock</code></a> the GIL before using this function.</p><p>The macro equivalent of <a href="#PythonCall.GIL.lock"><code>lock</code></a>.</p><div class="admonition is-warning" id="Warning-590f924a3424eed6"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-590f924a3424eed6" title="Permalink"></a></header><div class="admonition-body"><p>This macro is experimental. Its semantics may be changed without notice.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/GIL/GIL.jl#L53-L67">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.GIL.unlock"><a class="docstring-binding" href="#PythonCall.GIL.unlock"><code>PythonCall.GIL.unlock</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">unlock(f)</code></pre><p>Unlock the GIL, compute <code>f()</code>, re-lock the GIL, then return the result of <code>f()</code>.</p><p>Use this to run non-Python code with the GIL unlocked, so allowing another thread to run Python code. That other thread can be a Julia thread, which must lock the GIL using <a href="#PythonCall.GIL.lock"><code>lock</code></a>.</p><p>See <a href="#PythonCall.GIL.@unlock"><code>@unlock</code></a> for the macro form.</p><div class="admonition is-warning" id="Warning-434658bd2e2cf008"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-434658bd2e2cf008" title="Permalink"></a></header><div class="admonition-body"><p>This function is experimental. Its semantics may be changed without notice.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/GIL/GIL.jl#L79-L93">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.GIL.@unlock"><a class="docstring-binding" href="#PythonCall.GIL.@unlock"><code>PythonCall.GIL.@unlock</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@unlock expr</code></pre><p>Unlock the GIL, compute <code>expr</code>, re-lock the GIL, then return the result of <code>expr</code>.</p><p>Use this to run non-Python code with the GIL unlocked, so allowing another thread to run Python code. That other thread can be a Julia thread, which must lock the GIL using <a href="#PythonCall.GIL.@lock"><code>@lock</code></a>.</p><p>The macro equivalent of <a href="#PythonCall.GIL.unlock"><code>unlock</code></a>.</p><div class="admonition is-warning" id="Warning-590f924a3424eed6"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-590f924a3424eed6" title="Permalink"></a></header><div class="admonition-body"><p>This macro is experimental. Its semantics may be changed without notice.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/GIL/GIL.jl#L103-L117">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.GC.gc"><a class="docstring-binding" href="#PythonCall.GC.gc"><code>PythonCall.GC.gc</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">PythonCall.GC.gc()</code></pre><p>Free any Python objects waiting to be freed.</p><p>These are objects that were finalized from a thread that was not holding the Python GIL at the time.</p><p>Like most PythonCall functions, this must only be called from the main thread (i.e. the thread currently holding the Python GIL.)</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/GC/GC.jl#L62-L72">source</a></div></details></article><h2 id="The-Python-interpreter"><a class="docs-heading-anchor" href="#The-Python-interpreter">The Python interpreter</a><a id="The-Python-interpreter-1"></a><a class="docs-heading-anchor-permalink" href="#The-Python-interpreter" title="Permalink"></a></h2><p>These functions are not exported. They give information about which Python interpreter is being used.</p><article><details class="docstring" open="true"><summary id="PythonCall.python_version"><a class="docstring-binding" href="#PythonCall.python_version"><code>PythonCall.python_version</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">python_version()</code></pre><p>The version of Python, or <code>missing</code> if not known.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/C/api.jl#L22-L26">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.python_executable_path"><a class="docstring-binding" href="#PythonCall.python_executable_path"><code>PythonCall.python_executable_path</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">python_executable_path()</code></pre><p>Path to the Python interpreter, or <code>missing</code> if not known.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/C/api.jl#L1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.python_library_path"><a class="docstring-binding" href="#PythonCall.python_library_path"><code>PythonCall.python_library_path</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">python_library_path()</code></pre><p>Path to libpython, or <code>missing</code> if not known.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/C/api.jl#L8-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.python_library_handle"><a class="docstring-binding" href="#PythonCall.python_library_handle"><code>PythonCall.python_library_handle</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">python_library_handle()</code></pre><p>Handle to the open libpython, or <code>C_NULL</code> if not known.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/C/api.jl#L15-L19">source</a></div></details></article><h2 id="Low-level-API"><a class="docs-heading-anchor" href="#Low-level-API">Low-level API</a><a id="Low-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-API" title="Permalink"></a></h2><p>The functions here are not exported. They are mostly unsafe in the sense that you can crash Julia by using them incorrectly.</p><article><details class="docstring" open="true"><summary id="PythonCall.pynew"><a class="docstring-binding" href="#PythonCall.pynew"><code>PythonCall.pynew</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pynew([ptr])</code></pre><p>A new <code>Py</code> representing the Python object at <code>ptr</code> (NULL by default).</p><p>If <code>ptr</code> is given and non-NULL, this function steals a reference to the Python object it points at, i.e. the new <code>Py</code> object owns a reference.</p><p>Note that NULL Python objects are not safe in the sense that most API functions will probably crash your Julia session if you pass a NULL argument.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/Py.jl#L42-L52">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pyisnull"><a class="docstring-binding" href="#PythonCall.pyisnull"><code>PythonCall.pyisnull</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pyisnull(x)</code></pre><p>True if the Python object <code>x</code> is NULL.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/Py.jl#L13-L17">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pycopy!"><a class="docstring-binding" href="#PythonCall.pycopy!"><code>PythonCall.pycopy!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pycopy!(dst::Py, src)</code></pre><p>Copy the Python object <code>src</code> into <code>dst</code>, so that they both represent the same object.</p><p>This function exists to support module-level constant Python objects. It is illegal to call most PythonCall API functions at the top level of a module (i.e. before <code>__init__()</code> has run) so you cannot do <code>const x = pything()</code> at the top level. Instead do <code>const x = pynew()</code> at the top level then <code>pycopy!(x, pything())</code> inside <code>__init__()</code>.</p><p>Assumes <code>dst</code> is NULL, otherwise a memory leak will occur.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/Py.jl#L66-L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.getptr"><a class="docstring-binding" href="#PythonCall.getptr"><code>PythonCall.getptr</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">getptr(x)</code></pre><p>Get the underlying pointer from the Python object <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/Py.jl#L20-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.pydel!"><a class="docstring-binding" href="#PythonCall.pydel!"><code>PythonCall.pydel!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pydel!(x::Py)</code></pre><p>Delete the Python object <code>x</code>.</p><p>DANGER! Use this function ONLY IF the Julia object <code>x</code> could have been garbage-collected anyway, i.e. was about to become unreachable. This means you MUST KNOW that no other part of the program has the Julia object <code>x</code>.</p><p>This decrements the reference count, sets the pointer to NULL and appends <code>x</code> to a cache of unused objects (<code>PYNULL_CACHE</code>).</p><p>This is an optimization to avoid excessive allocation and deallocation in Julia, which can be a significant source of slow-down in code which uses a lot of Python objects. It allows <code>pynew()</code> to pop an item from <code>PYNULL_CACHE</code> instead of allocating one, and avoids calling the relatively slow finalizer on <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/Py.jl#L80-L96">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.unsafe_pynext"><a class="docstring-binding" href="#PythonCall.unsafe_pynext"><code>PythonCall.unsafe_pynext</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">unsafe_pynext(x)</code></pre><p>Return the next item in the iterator <code>x</code>. When there are no more items, return NULL.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/Core/builtins.jl#L516-L520">source</a></div></details></article><h2 id="NumpyDates"><a class="docs-heading-anchor" href="#NumpyDates">NumpyDates</a><a id="NumpyDates-1"></a><a class="docs-heading-anchor-permalink" href="#NumpyDates" title="Permalink"></a></h2><p>The submodule <code>PythonCall.NumpyDates</code> provides types corresponding to Numpy&#39;s <code>datetime64</code> and <code>timedelta64</code> types. Enables conversion of these Numpy types (either as scalars or in arrays) to native Julia types.</p><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates"><a class="docstring-binding" href="#PythonCall.NumpyDates"><code>PythonCall.NumpyDates</code></a> — <span class="docstring-category">Module</span></summary><div><pre><code class="language-julia hljs">module NumpyDates</code></pre><p>Provides datetimes and timedeltas compatible with Numpy.</p><p>See: <a href="#PythonCall.NumpyDates.DateTime64"><code>DateTime64</code></a>, <a href="#PythonCall.NumpyDates.InlineDateTime64"><code>InlineDateTime64</code></a>, <a href="#PythonCall.NumpyDates.TimeDelta64"><code>TimeDelta64</code></a> and <a href="#PythonCall.NumpyDates.InlineTimeDelta64"><code>InlineTimeDelta64</code></a>.</p><p>These can generally be converted to/from their respective types in the <code>Dates</code> stdlib.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/NumpyDates.jl#L1-L10">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.AbstractDateTime64"><a class="docstring-binding" href="#PythonCall.NumpyDates.AbstractDateTime64"><code>PythonCall.NumpyDates.AbstractDateTime64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractDateTime64 &lt;: Dates.TimeType</code></pre><p>Supertype for <a href="#PythonCall.NumpyDates.DateTime64"><code>DateTime64</code></a> and <a href="#PythonCall.NumpyDates.InlineDateTime64"><code>InlineDateTime64</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/AbstractDateTime64.jl#L1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.InlineDateTime64"><a class="docstring-binding" href="#PythonCall.NumpyDates.InlineDateTime64"><code>PythonCall.NumpyDates.InlineDateTime64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">InlineDateTime64{unit}(value)
InlineDateTime64{unit}(value, format)
InlineDateTime64(value, [unit])
InlineDateTime64(value, format, [unit])</code></pre><p>Construct an <code>InlineDateTime64</code> with the given <code>value</code> and <a href="#PythonCall.NumpyDates.Unit"><code>unit</code></a>.</p><p>The unit is part of the type, so an instance just consists of one <code>Int64</code> for the value.</p><p>The <code>value</code> can be:</p><ul><li>An <code>Integer</code>, in which case the <code>unit</code> is required.</li><li>A <code>Dates.Date</code> or <code>Dates.DateTime</code>.</li><li><code>&quot;NaT&quot;</code> or <code>&quot;NaN&quot;</code> to make a not-a-time value.</li><li>An <code>AbstractString</code>, which is parsed the same as <code>Dates.DateTime</code>, with an optional <code>format</code> string.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/InlineDateTime64.jl#L3-L19">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.DateTime64"><a class="docstring-binding" href="#PythonCall.NumpyDates.DateTime64"><code>PythonCall.NumpyDates.DateTime64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">DateTime64(value, [unit])
DateTime64(value, format, [unit])</code></pre><p>Construct an <code>DateTime64</code> with the given <code>value</code> and <a href="#PythonCall.NumpyDates.Unit"><code>unit</code></a>.</p><p>The unit is stored as a run-time value. If the units in your code are known, using <a href="#PythonCall.NumpyDates.InlineDateTime64"><code>InlineDateTime64{unit}</code></a> may be preferable. The memory layout is the same as for a <code>numpy.datetime64</code>.</p><p>The value can be:</p><ul><li>An <code>Integer</code>, in which case the <code>unit</code> is required.</li><li>A <code>Dates.Date</code> or <code>Dates.DateTime</code>.</li><li><code>&quot;NaT&quot;</code> or <code>&quot;NaN&quot;</code> to make a not-a-time value.</li><li>An <code>AbstractString</code>, which is parsed the same as <code>Dates.DateTime</code>, with an optional <code>format</code> string.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/DateTime64.jl#L3-L19">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.AbstractTimeDelta64"><a class="docstring-binding" href="#PythonCall.NumpyDates.AbstractTimeDelta64"><code>PythonCall.NumpyDates.AbstractTimeDelta64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractTimeDelta64 &lt;: Dates.Period</code></pre><p>Supertype for <a href="#PythonCall.NumpyDates.TimeDelta64"><code>TimeDelta64</code></a> and <a href="#PythonCall.NumpyDates.InlineTimeDelta64"><code>InlineTimeDelta64</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/AbstractTimeDelta64.jl#L1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.InlineTimeDelta64"><a class="docstring-binding" href="#PythonCall.NumpyDates.InlineTimeDelta64"><code>PythonCall.NumpyDates.InlineTimeDelta64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">InlineTimeDelta64{unit}(value)
InlineTimeDelta64(value, [unit])</code></pre><p>Construct an <code>InlineTimeDelta64</code> with the given <code>value</code> and <a href="#PythonCall.NumpyDates.Unit"><code>unit</code></a>.</p><p>The unit is part of the type, so an instance just consists of one <code>Int64</code> for the value.</p><p>The value can be:</p><ul><li>An <code>Integer</code>, in which case the <code>unit</code> is required.</li><li><code>&quot;NaT&quot;</code> or <code>&quot;NaN&quot;</code> to make a not-a-time value.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/InlineTimeDelta64.jl#L3-L14">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.TimeDelta64"><a class="docstring-binding" href="#PythonCall.NumpyDates.TimeDelta64"><code>PythonCall.NumpyDates.TimeDelta64</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">TimeDelta64(value, [unit])</code></pre><p>Construct a <code>TimeDelta64</code> with the given <code>value</code> and <a href="#PythonCall.NumpyDates.Unit"><code>unit</code></a>.</p><p>The unit is stored as a run-time value. If the units in your code are known, using <a href="#PythonCall.NumpyDates.InlineTimeDelta64"><code>InlineTimeDelta64{unit}</code></a> may be preferable. The memory layout is the same as for a <code>numpy.timedelta64</code>.</p><p>The value can be:</p><ul><li>An <code>Integer</code>, in which case the <code>unit</code> is required.</li><li><code>&quot;NaT&quot;</code> or <code>&quot;NaN&quot;</code> to make a not-a-time value.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/TimeDelta64.jl#L3-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="PythonCall.NumpyDates.Unit"><a class="docstring-binding" href="#PythonCall.NumpyDates.Unit"><code>PythonCall.NumpyDates.Unit</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">@enum Unit</code></pre><p>The possible time units for datetimes and timedeltas in this module.</p><p>Values are: <code>YEARS</code>, <code>MONTHS</code>, <code>WEEKS</code>, <code>DAYS</code>, <code>HOURS</code>, <code>MINUTES</code>, <code>SECONDS</code>, <code>MILLISECONDS</code>, <code>MICROSECONDS</code>, <code>NANOSECONDS</code>, <code>PICOSECONDS</code>, <code>FEMTOSECONDS</code>, <code>ATTOSECONDS</code>.</p><p>For compatibility with numpy, the types in this module also accept scaled units as a <code>Tuple{Unit,Int}</code>. For example <code>(MINUTES, 15)</code> for units of 15 minutes. This feature is rarely used.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/PythonCall.jl/blob/2ff3c8413cb13c1f05bba3f087ee11fb17937b36/src/NumpyDates/Unit.jl#L1-L13">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pythoncall/">« Guide</a><a class="docs-footer-nextpage" href="../juliacall/">Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 14 November 2025 21:20">Friday 14 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
