<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · PythonCall &amp; JuliaCall</title><meta name="title" content="Guide · PythonCall &amp; JuliaCall"/><meta property="og:title" content="Guide · PythonCall &amp; JuliaCall"/><meta property="twitter:title" content="Guide · PythonCall &amp; JuliaCall"/><meta name="description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="og:description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="twitter:description" content="Documentation for PythonCall &amp; JuliaCall."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; JuliaCall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; JuliaCall</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">The Julia module PythonCall</span><ul><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#py_getting_started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Executing-Python-scripts"><span>Executing Python scripts</span></a></li><li><a class="tocitem" href="#Conversion-between-Julia-and-Python"><span>Conversion between Julia and Python</span></a></li><li><a class="tocitem" href="#py-wrappers"><span>Wrapper types</span></a></li><li><a class="tocitem" href="#pythoncall-config"><span>Configuration</span></a></li><li><a class="tocitem" href="#python-deps"><span>Installing Python packages</span></a></li><li><a class="tocitem" href="#Writing-packages-which-depend-on-PythonCall"><span>Writing packages which depend on PythonCall</span></a></li><li><a class="tocitem" href="#jl-multi-threading"><span>Multi-threading</span></a></li></ul></li><li><a class="tocitem" href="../pythoncall-reference/">Reference</a></li></ul></li><li><span class="tocitem">The Python module JuliaCall</span><ul><li><a class="tocitem" href="../juliacall/">Guide</a></li><li><a class="tocitem" href="../juliacall-reference/">Reference</a></li></ul></li><li><span class="tocitem">Conversion</span><ul><li><a class="tocitem" href="../conversion-to-python/">Julia to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Python to Julia</a></li></ul></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li><a class="tocitem" href="../faq/">FAQ &amp; Troubleshooting</a></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">The Julia module PythonCall</a></li><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl/blob/main/docs/src/pythoncall.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Julia-module-PythonCall"><a class="docs-heading-anchor" href="#The-Julia-module-PythonCall">The Julia module PythonCall</a><a id="The-Julia-module-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#The-Julia-module-PythonCall" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is in the general registry, so to install just type <code>]</code> in the Julia REPL and run:</p><pre><code class="language-julia-repl hljs">pkg&gt; add PythonCall</code></pre><h2 id="py_getting_started"><a class="docs-heading-anchor" href="#py_getting_started">Getting started</a><a id="py_getting_started-1"></a><a class="docs-heading-anchor-permalink" href="#py_getting_started" title="Permalink"></a></h2><p>Import the module with:</p><pre><code class="language-julia-repl hljs">julia&gt; using PythonCall</code></pre><p>By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter. See <a href="#pythoncall-config">here</a> to configure which Python to use.</p><p>Now you can interact with Python as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; re = pyimport(&quot;re&quot;)
Python: &lt;module &#39;re&#39; from &#39;[...]/lib/re.py&#39;&gt;

julia&gt; words = re.findall(&quot;[a-zA-Z]+&quot;, &quot;PythonCall.jl is very useful!&quot;)
Python: [&#39;PythonCall&#39;, &#39;jl&#39;, &#39;is&#39;, &#39;very&#39;, &#39;useful&#39;]

julia&gt; sentence = Py(&quot; &quot;).join(words)
Python: &#39;PythonCall jl is very useful&#39;

julia&gt; pyconvert(String, sentence)
&quot;PythonCall jl is very useful&quot;</code></pre><p>In this example:</p><ul><li>We used <a href="../pythoncall-reference/#PythonCall.pyimport"><code>pyimport</code></a> to import the <code>re</code> module.</li><li>We called its <code>findall</code> function on a pair of strings, which were automatically converted to Python strings (see <a href="../conversion-to-python/#jl2py">Conversion to Python</a>).</li><li>We called <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a> to explicitly convert a string to a Python string, so that we could call its <code>join</code> method. All Python objects are of type <code>Py</code>.</li><li>We called <a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a> to convert the Python string <code>sentence</code> to a Julia string (see <a href="../conversion-to-julia/#py2jl">Conversion to Julia</a>).</li></ul><p>The values <code>re</code>, <code>words</code> and <code>sentence</code> in the example are all Python objects, which have type <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a> in Julia. As we have seen, these objects support attribute access (e.g. <code>re.findall</code>) and function calls (e.g. <code>join(words)</code>). They also support indexing, comparison and arithmetic:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3, 4, 5])
Python: [3, 4, 5]

julia&gt; x[2] == 5
Python: True

julia&gt; x[pyslice(0,2)] + pylist([1,2])
Python: [3, 4, 1, 2]</code></pre><p>We have just seen the functions <a href="../pythoncall-reference/#PythonCall.pylist"><code>pylist</code></a> (for constructing a Python list) and <a href="../pythoncall-reference/#PythonCall.pyslice"><code>pyslice</code></a> (for constructing a Python slice). There are many such functions, mirroring most of the Python builtin functions and types. The <a href="../pythoncall-reference/#py-reference">API Reference</a> documents them all.</p><p>Most of these functions are essentially Python builtins with a <code>py</code> prefix. For example <code>pyint(x)</code> converts <code>x</code> to a Python <code>int</code> and is equivalent to <code>int(x)</code> in Python when <code>x</code> is a Python object.</p><p>Notable exceptions are:</p><ul><li><a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a> to convert a Python object to a Julia object.</li><li><a href="../pythoncall-reference/#PythonCall.pyimport"><code>pyimport</code></a> to import a Python module.</li><li><a href="../pythoncall-reference/#PythonCall.pyjl"><code>pyjl</code></a> to directly wrap a Julia object as a Python object.</li><li><a href="../pythoncall-reference/#PythonCall.pywith"><code>pywith</code></a> to emulate the Python <code>with</code> statement.</li></ul><p>To access the Python builtins directly, you can access the fields of <a href="../pythoncall-reference/#PythonCall.pybuiltins"><code>pybuiltins</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; pybuiltins.None
Python: None

julia&gt; pybuiltins.True
Python: True

julia&gt; pybuiltins.ValueError(&quot;some error&quot;)
Python: ValueError(&#39;some error&#39;)</code></pre><p>With the functions introduced so far, you have access to the vast majority of Python&#39;s functionality.</p><h2 id="Executing-Python-scripts"><a class="docs-heading-anchor" href="#Executing-Python-scripts">Executing Python scripts</a><a id="Executing-Python-scripts-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Python-scripts" title="Permalink"></a></h2><p>A common use case is calling multiple blocks of Python code from Julia interactively. This can be accomplished in PythonCall via the <a href="../pythoncall-reference/#PythonCall.@pyexec">@pyexec</a> macro. For example, the sentence parsing application in the <a href="#py_getting_started">Getting started</a> section could be rewritten as:</p><pre><code class="language-julia-repl hljs">julia&gt; @pyexec &quot;&quot;&quot;
           global re
           import re

           def my_sentence(s):
               words = re.findall(&quot;[a-zA-Z]+&quot;, s)
               sentence = &quot; &quot;.join(words)
               return sentence
           &quot;&quot;&quot; =&gt; my_sentence
Python: &lt;function my_sentence at 0x7d83bb1b01a0&gt;

julia&gt; sentence = my_sentence(&quot;PythonCall.jl is very useful!&quot;)
Python: &#39;PythonCall jl is very useful&#39;</code></pre><p>Note the use of the <code>global</code> keyword to make the <code>re</code> package accessible in global scope, and the <code>=&gt; my_sentence</code> syntax to create a Julia function named <code>my_sentence</code> that calls to the Python function of the same name. This syntax also supports calling to multiple functions and passing data back-and-forth:</p><pre><code class="language-julia-repl hljs">julia&gt; @pyexec (num=10) =&gt; &quot;&quot;&quot;
           def add(a, b):
             return a + b

           def subtract(a, b):
               return a - b

           plusone = num + 1
           &quot;&quot;&quot; =&gt; (add, subtract, plusone::Float64)
(add = &lt;py function add at 0x721b001a7cc0&gt;, subtract = &lt;py function subtract at 0x721b001a7d70&gt;, plusone = 11.0)

julia&gt; add(4, 3)
Python: 7

julia&gt; subtract(4, 3)
Python: 1

julia&gt; plusone
11.0</code></pre><p>Here we demonstrate passing a named variable, <code>num</code>, via the use of the <code>=&gt;</code> syntax again, and returning named output, with the last element, <code>plusone</code>, being cast to a Julia object via the <code>::</code> syntax. See <a href="../pythoncall-reference/#PythonCall.@pyexec">@pyexec</a>, <a href="../pythoncall-reference/#PythonCall.@pyeval">@pyeval</a>, and their functional forms <a href="../pythoncall-reference/#PythonCall.pyexec">pyexec</a> and <a href="../pythoncall-reference/#PythonCall.pyeval">pyeval</a>, for more.</p><h2 id="Conversion-between-Julia-and-Python"><a class="docs-heading-anchor" href="#Conversion-between-Julia-and-Python">Conversion between Julia and Python</a><a id="Conversion-between-Julia-and-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-Julia-and-Python" title="Permalink"></a></h2><p>A Julia object can be converted to a Python one either explicitly (such as <code>Py(x)</code>) or implicitly (such as the arguments when calling a Python function). Either way, it follows the default conversion rules <a href="../conversion-to-python/#jl2py">here</a>.</p><p>Most operations involving Python objects will return a <code>Py</code> and are not automatically converted to another Julia type. Instead, you can explicitly convert using <a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3.4, 5.6])
Python: [3.4, 5.6]

julia&gt; pyconvert(Vector, x)
2-element Vector{Float64}:
 3.4
 5.6

julia&gt; pyconvert(Vector{Float32}, x)
2-element Vector{Float32}:
 3.4
 5.6

julia&gt; pyconvert(Any, x)
2-element PyList{Any}:
 3.4
 5.6</code></pre><p>In the above example, we converted a Python list to a Julia vector in three ways.</p><ul><li><code>pyconvert(Vector, x)</code> returned a <code>Vector{Float64}</code> since all the list items are floats.</li><li><code>pyconvert(Vector{Float32}, x)</code> specified the element type, so the floats were converted to <code>Float32</code>.</li><li><code>pyconvert(Any, x)</code> returned a <code>PyList{Py}</code> which is a no-copy wrapper around the original list <code>x</code>, viewing it as a <code>AbstractVector{Py}</code>. Since it is a wrapper, mutating it mutates <code>x</code> and vice-versa.</li></ul><p>See <a href="../conversion-to-julia/#py2jl">here</a> for the rules regarding how <code>pyconvert(T, x)</code> works. If <code>x</code> is an immutable scalar type (such as an <code>int</code> or <code>str</code>) then <code>pyconvert(Any, x)</code> may return the corresponding Julia object (such as an <code>Integer</code> or <code>String</code>). Otherwise it will typically return either a <a href="#py-wrappers">wrapper type</a> (such as <code>PyList{Py}</code> in the above example) or will fall back to returning a <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a>.</p><h2 id="py-wrappers"><a class="docs-heading-anchor" href="#py-wrappers">Wrapper types</a><a id="py-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#py-wrappers" title="Permalink"></a></h2><p>A wrapper is a type which wraps a Python object but provides it with the semantics of some other Julia type.</p><p>Since it is merely wrapping a Python object, if you mutate the wrapper you also mutate the wrapped object, and vice versa.</p><p>See <a href="../pythoncall-reference/#python-wrappers">here</a> for details of all the wrapper types provided by PythonCall.</p><p>We have already seen <a href="../pythoncall-reference/#PythonCall.PyList"><code>PyList</code></a>. It wraps any Python sequence (such as a list) as a Julia vector:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3,4,5])
Python: [3, 4, 5]

julia&gt; y = PyList{Union{Int,Nothing}}(x)
3-element PyList{Union{Nothing, Int64}}:
 3
 4
 5

julia&gt; push!(y, nothing)
4-element PyList{Union{Nothing, Int64}}:
 3
 4
 5
  nothing

julia&gt; append!(y, 1:2)
6-element PyList{Union{Nothing, Int64}}:
 3
 4
 5
  nothing
 1
 2

julia&gt; x
Python: [3, 4, 5, None, 1, 2]</code></pre><p>There are wrappers for other container types, such as <a href="../pythoncall-reference/#PythonCall.PyDict"><code>PyDict</code></a> and <a href="../pythoncall-reference/#PythonCall.PySet"><code>PySet</code></a>.</p><p>The wrapper <a href="../pythoncall-reference/#PythonCall.PyArray"><code>PyArray</code></a> provides a Julia array view of any Python array, i.e. anything satisfying either the buffer protocol or the numpy array interface. This includes things like <code>bytes</code>, <code>bytearray</code>, <code>array.array</code> and <code>numpy.ndarray</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pyimport(&quot;array&quot;).array(&quot;i&quot;, [3, 4, 5])
Python: array(&#39;i&#39;, [3, 4, 5])

julia&gt; y = PyArray(x)
3-element PyArray{Int32, 1, true, true, Int32}:
 3
 4
 5

julia&gt; sum(y)
12

julia&gt; y[1] = 0
0

julia&gt; x
Python: array(&#39;i&#39;, [0, 4, 5])</code></pre><p>It directly wraps the underlying data buffer, so array operations such as indexing are about as fast as for an ordinary <code>Array</code>.</p><p>The <a href="../pythoncall-reference/#PythonCall.PyIO"><code>PyIO</code></a> wrapper type views a Python file object as a Julia IO object:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pyimport(&quot;io&quot;).StringIO()
Python: &lt;_io.StringIO object at 0x000000006579BC70&gt;

julia&gt; y = PyIO(x)
PyIO(&lt;py _io.StringIO object at 0x000000006579BC70&gt;, false, true, false, 4096, UInt8[], 4096, UInt8[])

julia&gt; println(y, &quot;Hello, world!&quot;)

julia&gt; flush(y)

julia&gt; x.seek(0)
Python: 0

julia&gt; x.read()
Python: &#39;Hello, world!\n&#39;</code></pre><h2 id="pythoncall-config"><a class="docs-heading-anchor" href="#pythoncall-config">Configuration</a><a id="pythoncall-config-1"></a><a class="docs-heading-anchor-permalink" href="#pythoncall-config" title="Permalink"></a></h2><p>By default, PythonCall uses <a href="https://github.com/JuliaPy/CondaPkg.jl">CondaPkg.jl</a> to manage its dependencies. This will install Conda and use it to create a Conda environment specific to your current Julia project containing Python and any required Python packages.</p><h4 id="If-you-already-have-Python-and-required-Python-packages-installed"><a class="docs-heading-anchor" href="#If-you-already-have-Python-and-required-Python-packages-installed">If you already have Python and required Python packages installed</a><a id="If-you-already-have-Python-and-required-Python-packages-installed-1"></a><a class="docs-heading-anchor-permalink" href="#If-you-already-have-Python-and-required-Python-packages-installed" title="Permalink"></a></h4><pre><code class="language-julia hljs">ENV[&quot;JULIA_CONDAPKG_BACKEND&quot;] = &quot;Null&quot;
ENV[&quot;JULIA_PYTHONCALL_EXE&quot;] = &quot;/path/to/python&quot;  # optional
ENV[&quot;JULIA_PYTHONCALL_EXE&quot;] = &quot;@PyCall&quot;  # optional
ENV[&quot;JULIA_PYTHONCALL_EXE&quot;] = &quot;@venv&quot; # optional</code></pre><p>By setting the CondaPkg backend to Null, it will never install any Conda packages. In this case, PythonCall will use whichever Python is currently installed and in your <code>PATH</code>. You must have already installed any Python packages that you need.</p><p>If <code>python</code> is not in your <code>PATH</code>, you will also need to set <code>JULIA_PYTHONCALL_EXE</code> to its path. Relative paths are resolved relative to the current active project.</p><p>If you also use PyCall, you can set <code>JULIA_PYTHONCALL_EXE=@PyCall</code> to use the same Python interpreter. <a href="../faq/#faq-pycall">See here</a>.</p><p>If you have a Python virtual environment at <code>.venv</code> in your current active project, you can set <code>JULIA_PYTHONCALL_EXE=@venv</code> to use it.</p><h4 id="If-you-already-have-a-Conda-environment"><a class="docs-heading-anchor" href="#If-you-already-have-a-Conda-environment">If you already have a Conda environment</a><a id="If-you-already-have-a-Conda-environment-1"></a><a class="docs-heading-anchor-permalink" href="#If-you-already-have-a-Conda-environment" title="Permalink"></a></h4><pre><code class="language-julia hljs">ENV[&quot;JULIA_CONDAPKG_BACKEND&quot;] = &quot;Current&quot;
ENV[&quot;JULIA_CONDAPKG_EXE&quot;] = &quot;/path/to/conda&quot;  # optional</code></pre><p>The Current backend to CondaPkg will use the currently activated Conda environment instead of creating a new one.</p><p>Note that this will still install any required Conda packages into your Conda environment. If you already have your dependencies installed and do not want the environment to be modified, then see the previous section.</p><p>If <code>conda</code>, <code>mamba</code> or <code>micromamba</code> is not in your <code>PATH</code> you will also need to set <code>JULIA_CONDAPKG_EXE</code> to its path.</p><h4 id="If-you-already-have-Conda,-Mamba-or-MicroMamba"><a class="docs-heading-anchor" href="#If-you-already-have-Conda,-Mamba-or-MicroMamba">If you already have Conda, Mamba or MicroMamba</a><a id="If-you-already-have-Conda,-Mamba-or-MicroMamba-1"></a><a class="docs-heading-anchor-permalink" href="#If-you-already-have-Conda,-Mamba-or-MicroMamba" title="Permalink"></a></h4><pre><code class="language-julia hljs">ENV[&quot;JULIA_CONDAPKG_BACKEND&quot;] = &quot;System&quot;
ENV[&quot;JULIA_CONDAPKG_EXE&quot;] = &quot;/path/to/conda&quot;  # optional</code></pre><p>The System backend to CondaPkg will use your preinstalled Conda implementation instead of downloading one.</p><p>Note that this will still create a new Conda environment and install any required packages into it. If you want to use a pre-existing Conda environment, see the previous section.</p><p>If <code>conda</code>, <code>mamba</code> or <code>micromamba</code> is not in your <code>PATH</code> you will also need to set <code>JULIA_CONDAPKG_EXE</code> to its path.</p><h2 id="python-deps"><a class="docs-heading-anchor" href="#python-deps">Installing Python packages</a><a id="python-deps-1"></a><a class="docs-heading-anchor-permalink" href="#python-deps" title="Permalink"></a></h2><p>Assuming you haven&#39;t <a href="#pythoncall-config">opted out</a>, PythonCall uses <a href="https://github.com/JuliaPy/CondaPkg.jl">CondaPkg.jl</a> to automatically install any required Python packages.</p><p>This is as simple as</p><pre><code class="language-julia-repl hljs">julia&gt; using CondaPkg

julia&gt; # press ] to enter the Pkg REPL

pkg&gt; conda add some_package</code></pre><p>This creates a <code>CondaPkg.toml</code> file in the active project specifying the dependencies, just like a <code>Project.toml</code> specifies Julia dependencies. Commit this file along with the rest of the project so that dependencies are automatically installed for everyone using it.</p><p>To add dependencies to a Julia package, just ensure the package project is activated first.</p><p>See the <a href="https://github.com/JuliaPy/CondaPkg.jl">CondaPkg.jl</a> documentation.</p><h2 id="Writing-packages-which-depend-on-PythonCall"><a class="docs-heading-anchor" href="#Writing-packages-which-depend-on-PythonCall">Writing packages which depend on PythonCall</a><a id="Writing-packages-which-depend-on-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-packages-which-depend-on-PythonCall" title="Permalink"></a></h2><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>See <a href="https://github.com/cjdoris/Faiss.jl">https://github.com/cjdoris/Faiss.jl</a> for an example package which wraps the Python FAISS package.</p><h3 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h3><p>You must not interact with Python during module precompilation. Therefore, instead of</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = pyimport(&quot;foo&quot;)
  bar() = foo.bar() # will crash when called
end</code></pre><p>you can do the import when the module is loaded, saving the result in a <code>Ref</code></p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = Ref{Py}()
  function __init__()
    foo[] = pyimport(&quot;foo&quot;)
  end
  bar() = foo[].bar()
end</code></pre><p>or you can perform any imports dynamically</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  bar() = pyimport(&quot;foo&quot;).bar()
end</code></pre><p>or if that is too slow, you can cache the import</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  bar() = @pyconst(pyimport(&quot;foo&quot;)).bar()
end</code></pre><p>or even cache the imported function</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  bar() = @pyconst(pyimport(&quot;foo&quot;).bar)()
end</code></pre><h3 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h3><p>If your package depends on some Python packages, you must generate a <code>CondaPkg.toml</code> file. See <a href="#python-deps">Installing Python packages</a>.</p><h2 id="jl-multi-threading"><a class="docs-heading-anchor" href="#jl-multi-threading">Multi-threading</a><a id="jl-multi-threading-1"></a><a class="docs-heading-anchor-permalink" href="#jl-multi-threading" title="Permalink"></a></h2><div class="admonition is-warning" id="Warning-515ca28cb059d818"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-515ca28cb059d818" title="Permalink"></a></header><div class="admonition-body"><p>Multi-threading support is experimental and can change without notice.</p></div></div><p>From v0.9.22, PythonCall supports multi-threading in Julia and/or Python, with some caveats.</p><p>Most importantly, you can only call Python code while Python&#39;s <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Global Interpreter Lock (GIL)</a> is locked by the current thread. Ordinarily, the GIL is locked by the main thread in Julia, so if you want to run Python code on any other thread, you must unlock the GIL from the main thread and then re-lock it while running any Python code on other threads.</p><p>This is made possible by the macros <a href="../pythoncall-reference/#PythonCall.GIL.@unlock"><code>PythonCall.GIL.@unlock</code></a> and <a href="../pythoncall-reference/#PythonCall.GIL.@lock"><code>PythonCall.GIL.@lock</code></a> or the functions <a href="../pythoncall-reference/#PythonCall.GIL.unlock"><code>PythonCall.GIL.unlock</code></a> and <a href="../pythoncall-reference/#PythonCall.GIL.lock"><code>PythonCall.GIL.lock</code></a> with this pattern:</p><pre><code class="language-julia hljs">PythonCall.GIL.@unlock Threads.@threads for i in 1:4
  PythonCall.GIL.@lock pyimport(&quot;time&quot;).sleep(5)
end</code></pre><p>In the above example, we call <code>time.sleep(5)</code> four times in parallel. If Julia was started with at least four threads (<code>julia -t4</code>) then the above code will take about 5 seconds.</p><p>Both <code>@unlock</code> and <code>@lock</code> are important. If the GIL were not unlocked, then a deadlock would occur when attempting to lock the already-locked GIL from the threads. If the GIL were not re-locked, then Python would crash when interacting with it.</p><p>With multiple Julia threads you need exactly one interactive thread, see the <a href="../faq/#faq-multi-threading">FAQ</a>.</p><p>You can also use <a href="../juliacall/#py-multi-threading">multi-threading from Python</a>.</p><h3 id="Caveat:-Garbage-collection"><a class="docs-heading-anchor" href="#Caveat:-Garbage-collection">Caveat: Garbage collection</a><a id="Caveat:-Garbage-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Caveat:-Garbage-collection" title="Permalink"></a></h3><p>If Julia&#39;s GC collects any Python objects from a thread where the GIL is not currently locked, then those Python objects will not immediately be deleted. Instead they will be queued to be deleted in a later GC pass.</p><p>If you find you have many Python objects not being deleted, you can call <a href="../pythoncall-reference/#PythonCall.GC.gc"><code>PythonCall.GC.gc()</code></a> or <code>GC.gc()</code> while the GIL is locked to clear the queue.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../pythoncall-reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 14 November 2025 21:22">Friday 14 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
