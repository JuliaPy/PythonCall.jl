var documenterSearchIndex = {"docs":
[{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#Unreleased","page":"Release Notes","title":"Unreleased","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Showing Py now respects the compact option - output is limited to a single line of at most the display width.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.28-(2025-09-17)","page":"Release Notes","title":"0.9.28 (2025-09-17)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Added NumpyDates: NumPy-compatible DateTime64/TimeDelta64 types and units.\nAdded pyconvert rules for NumpyDates types.\nAdded PyArray support for NumPy arrays of datetime64 and timedelta64.\nAdded juliacall.ArrayValue support for Julia arrays of InlineDateTime64 and InlineTimeDelta64.\nIf JULIA_PYTHONCALL_EXE is a relative path, it is now considered relative to the active project.\nAdded option JULIA_PYTHONCALL_EXE=@venv to use a Python virtual environment relative to the active project.\nAdded PYTHON_JULIACALL_EXE and PYTHON_JULIACALL_PROJECT for specifying the Julia binary and project to override JuliaPkg.\nAdds methods Py(::AbstractString), Py(::AbstractChar) (previously only builtin string and char types were allowed).\nAdds methods Py(::Integer), Py(::Rational{<:Integer}), Py(::AbstractRange{<:Integer}) (previously only builtin integer types were allowed).\nAdds method pydict(::Pair...) to construct a python dict from Pairs, similar to Dict.\nBug fixes.\nInternal: switch from Requires.jl to package extensions.","category":"page"},{"location":"releasenotes/#0.9.27-(2025-08-19)","page":"Release Notes","title":"0.9.27 (2025-08-19)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Internal: Use heap-allocated types (PyType_FromSpec) to improve ABI compatibility.\nMinimum supported Python version is now 3.9.\nBetter compatibility with libstdc++.","category":"page"},{"location":"releasenotes/#0.9.26-(2025-07-15)","page":"Release Notes","title":"0.9.26 (2025-07-15)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Added PySide6 support to the GUI compatibility layer.\nAdded FAQ on interactive threads.\nAdded CI benchmarking suite.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.25-(2025-05-13)","page":"Release Notes","title":"0.9.25 (2025-05-13)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Added PYTHON_JULIACALL_HEAP_SIZE_HINT option to configure initial Julia heap size.\nBase.elsize now defined for PyArray.\nJuliaCall now ensures a version of OpenSSL_jll compatible with Python is installed.","category":"page"},{"location":"releasenotes/#0.9.24-(2025-01-22)","page":"Release Notes","title":"0.9.24 (2025-01-22)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.23-(2024-08-22)","page":"Release Notes","title":"0.9.23 (2024-08-22)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.22-(2024-08-07)","page":"Release Notes","title":"0.9.22 (2024-08-07)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Finalizers are now thread-safe, meaning PythonCall now works in the presence of multi-threaded Julia code. Previously, tricks such as disabling the garbage collector were required. Python code must still be called on the main thread.\nGC.disable() and GC.enable() are now a no-op and deprecated since they are no longer required for thread-safety. These will be removed in v1.\nAdds GC.gc().\nAdds module GIL with lock(), unlock(), @lock and @unlock for handling the Python Global Interpreter Lock. In combination with the above improvements, these allow Julia and Python to co-operate on multiple threads.\nAdds method _jl_call_nogil to juliacall.AnyValue and juliacall.RawValue to call Julia functions with the GIL unlocked.","category":"page"},{"location":"releasenotes/#0.9.21-(2024-07-20)","page":"Release Notes","title":"0.9.21 (2024-07-20)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Serialization.serialize can use dill instead of pickle by setting the env var JULIA_PYTHONCALL_PICKLE=dill.\nnumpy.bool_ can now be converted to Bool and other number types.\ndatetime.timedelta can now be converted to Dates.Nanosecond, Microsecond, Millisecond and Second. This behaviour was already documented.\nIn JuliaCall, the Julia runtime is now properly terminated when Python exits. This means all finalizers should always run.\nNULL Python objects (such as from pynew()) can be safely displayed in multimedia contexts (VSCode/Pluto/etc.)","category":"page"},{"location":"releasenotes/#0.9.20-(2024-05-01)","page":"Release Notes","title":"0.9.20 (2024-05-01)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"The IPython extension is now automatically loaded upon import if IPython is detected.\nJuliaCall now compatible with Julia 1.10.3.\nMinimum supported Python version is now 3.8.","category":"page"},{"location":"releasenotes/#0.9.19-(2024-03-19)","page":"Release Notes","title":"0.9.19 (2024-03-19)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.18-(2024-03-18)","page":"Release Notes","title":"0.9.18 (2024-03-18)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.17-(2024-03-16)","page":"Release Notes","title":"0.9.17 (2024-03-16)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.16-(2024-03-14)","page":"Release Notes","title":"0.9.16 (2024-03-14)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Big internal refactor.\nNew unexported functions: python_executable_path, python_library_path, python_library_handle and python_version.\nPy is now treated as a scalar when broadcasting.\nPyArray is now serializable.\nRemoved compatibility with Julia 1.10.1 and 1.10.2 (to be fixed in 1.10.3 and 1.11.0) due to an upstream bug.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.15-(2023-10-25)","page":"Release Notes","title":"0.9.15 (2023-10-25)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"JuliaCall now supports -X juliacall-startup-file=no to disable running startup.jl.\nIf you are using CondaPkg then Python can optionally now be installed from the anaconda channel (instead of only conda-forge).\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.14-(2023-07-26)","page":"Release Notes","title":"0.9.14 (2023-07-26)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Wrapped Julia values support truthiness (__bool__) better: all values are true, except for zero numbers and empty arrays, dicts and sets.\nJuliaCall now supports the Julia --handle-signals option. Setting this to yes allows allocating multithreaded Julia code to be called from JuliaCall without segfaulting. The default is no while compatibility concerns are investigated, and may be changed to yes in a future release.","category":"page"},{"location":"releasenotes/#0.9.13-(2023-05-14)","page":"Release Notes","title":"0.9.13 (2023-05-14)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Conversion to wrapper types PyList, PySet, PyDict or PyIterable now default to having element type Any instead of Py.\nThe __repr__ method of wrapped Julia objects now uses the 3-arg show method for nicer (richer and truncated) display at the Python REPL.\nThe IPython extension can now be loaded as just %load_ext juliacall.\nThe %%julia IPython magic can now synchronise variables between Python and Julia.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.12-(2023-02-28)","page":"Release Notes","title":"0.9.12 (2023-02-28)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.11-(2023-02-15)","page":"Release Notes","title":"0.9.11 (2023-02-15)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"In PyArray{T}(x), the eltype T no longer needs to exactly match the stored data type. If x has numeric elements, then any number type T is allowed. If x has string elements, then any string type T is allowed.\nStaticString (the inline string type used by PyArray) supports the AbstractString interface better.","category":"page"},{"location":"releasenotes/#0.9.10-(2022-12-02)","page":"Release Notes","title":"0.9.10 (2022-12-02)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.9-(2022-10-20)","page":"Release Notes","title":"0.9.9 (2022-10-20)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.8-(2022-10-18)","page":"Release Notes","title":"0.9.8 (2022-10-18)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Adds line_buffering option to PyIO.\nImprovements to stdout when using juliacall.ipython including line-buffering.","category":"page"},{"location":"releasenotes/#0.9.7-(2022-10-11)","page":"Release Notes","title":"0.9.7 (2022-10-11)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"If CondaPkg is using the Null backend, PythonCall will now use python from the PATH.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.6-(2022-09-09)","page":"Release Notes","title":"0.9.6 (2022-09-09)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"When using JuliaCall from an interactive Python session, Julia is put into interactive mode: isinteractive() is true, InteractiveUtils is loaded, and a nicer display is used.\nWrapped Julia values now truncate their output when displayed via _repr_mimebundle_.\nNumpy arrays with structured dtypes can now be converted to PyArray, provided the fields are aligned.\nPython named tuples can be converted to Julia named tuples.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.5-(2022-08-19)","page":"Release Notes","title":"0.9.5 (2022-08-19)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Adds PythonCall.GC.disable() and PythonCall.GC.enable().\nExperimental new function juliacall.interactive() allows the Julia async event loop to run in the background of the Python REPL.\nExperimental new IPython extension juliacall.ipython providing the %julia and %%julia magics for executing Julia code.\nExperimental new module juliacall.importer allowing you to write Python modules in Julia.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.4-(2022-07-26)","page":"Release Notes","title":"0.9.4 (2022-07-26)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.3-(2022-07-02)","page":"Release Notes","title":"0.9.3 (2022-07-02)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#0.9.2-(2022-07-02)","page":"Release Notes","title":"0.9.2 (2022-07-02)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Many Julia CLI options (such sysimage or number of threads) can be set from JuliaCall.\nBug fixes.","category":"page"},{"location":"releasenotes/#0.9.1-(2022-06-18)","page":"Release Notes","title":"0.9.1 (2022-06-18)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"PyArray can be constructed using the __array_struct__ part of the Numpy array interface. Constructing PyArray(x) is now about 50x faster, or 175x faster if you fully specify the type.\nJuliaCall can now be imported on Apple M1.","category":"page"},{"location":"releasenotes/#0.9.0-(2022-05-27)","page":"Release Notes","title":"0.9.0 (2022-05-27)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking. Removes getpy: you may now overload Py directly, which now need not always return a new object (e.g. for singletons or wrappers).\nBreaking. Conversion rules no longer take a new object every time.\nBreaking. Improved Tables-interface support for PyPandasDataFrame: better inferred column types; better handling of non-string column names; columns are usually wrappers (PyArray or PyList). Constructor arguments have changed. Dict methods have been removed (basically only the Tables interface is supported).\nBreaking. A Py which is convertible to PyTable is no longer considered to be a table itself; you must convert explicitly.\nAdds pyhasitem and 3-arg pygetitem.\nExtends Base.get, Base.get!, Base.haskey and 2-arg Base.hash for Py.\nPyArray can now have any element type when the underlying array is of Python objects.\nAdds ArrayValue.to_numpy().\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.8.0-(2022-03-17)","page":"Release Notes","title":"v0.8.0 (2022-03-17)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: Removes pymethod and pyclass. In the future, pyclass may become sugar for types.new_class (namely you can specify a metaclass).\nAdds pyfunc, pyclassmethod, pystaticmethod and pyproperty.\npyconvert_add_rule is now documented. Its semantics have changed, including the separator of the first argument from / to :.\nA pandas <NA> value is now converted to missing.\nA NaN in a PyPandasDataFrame is converted to missing.\nBreaking: Removes using and As from JuliaCall.\nAdds convert to JuliaCall (replacing As).\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.6.1-(2022-02-21)","page":"Release Notes","title":"v0.6.1 (2022-02-21)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Conversions from simple ctypes types, e.g. ctypes.c_float to Cfloat.\nConversions from simple numpy types, e.g. numpy.float32 to Float32.\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.6.0-(2022-02-17)","page":"Release Notes","title":"v0.6.0 (2022-02-17)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: JuliaCall now uses JuliaPkg to manage Julia dependencies.\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.5.1-(2022-01-24)","page":"Release Notes","title":"v0.5.1 (2022-01-24)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#v0.5.0-(2021-12-11)","page":"Release Notes","title":"v0.5.0 (2021-12-11)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: PythonCall now uses CondaPkg to manage Python dependencies.\nPython objects can be shared with PyCall provided it uses the same interpreter, using methods PythonCall.Py(::PyCall.PyObject) and PyCall.PyObject(::PythonCall.Py).\nAdds PythonDisplay which displays objects by printing to Python's sys.stdout. Used automatically in IPython in addition to IPythonDisplay.\nRemoves the GLOBAL mode from @pyexec. Use global in the code instead.\nBug fixes.","category":"page"},{"location":"pythoncall/#The-Julia-module-PythonCall","page":"Guide","title":"The Julia module PythonCall","text":"","category":"section"},{"location":"pythoncall/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"This package is in the general registry, so to install just type ] in the Julia REPL and run:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"pkg> add PythonCall","category":"page"},{"location":"pythoncall/#Getting-started","page":"Guide","title":"Getting started","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Import the module with:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> using PythonCall","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter. See here to configure which Python to use.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Now you can interact with Python as follows:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> re = pyimport(\"re\")\nPython: <module 're' from '[...]/lib/re.py'>\n\njulia> words = re.findall(\"[a-zA-Z]+\", \"PythonCall.jl is very useful!\")\nPython: ['PythonCall', 'jl', 'is', 'very', 'useful']\n\njulia> sentence = Py(\" \").join(words)\nPython: 'PythonCall jl is very useful'\n\njulia> pyconvert(String, sentence)\n\"PythonCall jl is very useful\"","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"In this example:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"We used pyimport to import the re module.\nWe called its findall function on a pair of strings, which were automatically converted to Python strings (see Conversion to Python).\nWe called Py to explicitly convert a string to a Python string, so that we could call its join method. All Python objects are of type Py.\nWe called pyconvert to convert the Python string sentence to a Julia string (see Conversion to Julia).","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"The values re, words and sentence in the example are all Python objects, which have type Py in Julia. As we have seen, these objects support attribute access (e.g. re.findall) and function calls (e.g. join(words)). They also support indexing, comparison and arithmetic:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> x = pylist([3, 4, 5])\nPython: [3, 4, 5]\n\njulia> x[2] == 5\nPython: True\n\njulia> x[pyslice(0,2)] + pylist([1,2])\nPython: [3, 4, 1, 2]","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"We have just seen the functions pylist (for constructing a Python list) and pyslice (for constructing a Python slice). There are many such functions, mirroring most of the Python builtin functions and types. The API Reference documents them all.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Most of these functions are essentially Python builtins with a py prefix. For example pyint(x) converts x to a Python int and is equivalent to int(x) in Python when x is a Python object.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Notable exceptions are:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"pyconvert to convert a Python object to a Julia object.\npyimport to import a Python module.\npyjl to directly wrap a Julia object as a Python object.\npywith to emulate the Python with statement.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"To access the Python builtins directly, you can access the fields of pybuiltins:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> pybuiltins.None\nPython: None\n\njulia> pybuiltins.True\nPython: True\n\njulia> pybuiltins.ValueError(\"some error\")\nPython: ValueError('some error')","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"With the functions introduced so far, you have access to the vast majority of Python's functionality.","category":"page"},{"location":"pythoncall/#Conversion-between-Julia-and-Python","page":"Guide","title":"Conversion between Julia and Python","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"A Julia object can be converted to a Python one either explicitly (such as Py(x)) or implicitly (such as the arguments when calling a Python function). Either way, it follows the default conversion rules here.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Most operations involving Python objects will return a Py and are not automatically converted to another Julia type. Instead, you can explicitly convert using pyconvert:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> x = pylist([3.4, 5.6])\nPython: [3.4, 5.6]\n\njulia> pyconvert(Vector, x)\n2-element Vector{Float64}:\n 3.4\n 5.6\n\njulia> pyconvert(Vector{Float32}, x)\n2-element Vector{Float32}:\n 3.4\n 5.6\n\njulia> pyconvert(Any, x)\n2-element PyList{Any}:\n 3.4\n 5.6","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"In the above example, we converted a Python list to a Julia vector in three ways.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"pyconvert(Vector, x) returned a Vector{Float64} since all the list items are floats.\npyconvert(Vector{Float32}, x) specified the element type, so the floats were converted to Float32.\npyconvert(Any, x) returned a PyList{Py} which is a no-copy wrapper around the original list x, viewing it as a AbstractVector{Py}. Since it is a wrapper, mutating it mutates x and vice-versa.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"See here for the rules regarding how pyconvert(T, x) works. If x is an immutable scalar type (such as an int or str) then pyconvert(Any, x) may return the corresponding Julia object (such as an Integer or String). Otherwise it will typically return either a wrapper type (such as PyList{Py} in the above example) or will fall back to returning a Py.","category":"page"},{"location":"pythoncall/#py-wrappers","page":"Guide","title":"Wrapper types","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"A wrapper is a type which wraps a Python object but provides it with the semantics of some other Julia type.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Since it is merely wrapping a Python object, if you mutate the wrapper you also mutate the wrapped object, and vice versa.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"See here for details of all the wrapper types provided by PythonCall.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"We have already seen PyList. It wraps any Python sequence (such as a list) as a Julia vector:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> x = pylist([3,4,5])\nPython: [3, 4, 5]\n\njulia> y = PyList{Union{Int,Nothing}}(x)\n3-element PyList{Union{Nothing, Int64}}:\n 3\n 4\n 5\n\njulia> push!(y, nothing)\n4-element PyList{Union{Nothing, Int64}}:\n 3\n 4\n 5\n  nothing\n\njulia> append!(y, 1:2)\n6-element PyList{Union{Nothing, Int64}}:\n 3\n 4\n 5\n  nothing\n 1\n 2\n\njulia> x\nPython: [3, 4, 5, None, 1, 2]","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"There are wrappers for other container types, such as PyDict and PySet.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"The wrapper PyArray provides a Julia array view of any Python array, i.e. anything satisfying either the buffer protocol or the numpy array interface. This includes things like bytes, bytearray, array.array and numpy.ndarray:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> x = pyimport(\"array\").array(\"i\", [3, 4, 5])\nPython: array('i', [3, 4, 5])\n\njulia> y = PyArray(x)\n3-element PyArray{Int32, 1, true, true, Int32}:\n 3\n 4\n 5\n\njulia> sum(y)\n12\n\njulia> y[1] = 0\n0\n\njulia> x\nPython: array('i', [0, 4, 5])","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"It directly wraps the underlying data buffer, so array operations such as indexing are about as fast as for an ordinary Array.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"The PyIO wrapper type views a Python file object as a Julia IO object:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> x = pyimport(\"io\").StringIO()\nPython: <_io.StringIO object at 0x000000006579BC70>\n\njulia> y = PyIO(x)\nPyIO(<py _io.StringIO object at 0x000000006579BC70>, false, true, false, 4096, UInt8[], 4096, UInt8[])\n\njulia> println(y, \"Hello, world!\")\n\njulia> flush(y)\n\njulia> x.seek(0)\nPython: 0\n\njulia> x.read()\nPython: 'Hello, world!\\n'","category":"page"},{"location":"pythoncall/#pythoncall-config","page":"Guide","title":"Configuration","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"By default, PythonCall uses CondaPkg.jl to manage its dependencies. This will install Conda and use it to create a Conda environment specific to your current Julia project containing Python and any required Python packages.","category":"page"},{"location":"pythoncall/#If-you-already-have-Python-and-required-Python-packages-installed","page":"Guide","title":"If you already have Python and required Python packages installed","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"ENV[\"JULIA_CONDAPKG_BACKEND\"] = \"Null\"\nENV[\"JULIA_PYTHONCALL_EXE\"] = \"/path/to/python\"  # optional\nENV[\"JULIA_PYTHONCALL_EXE\"] = \"@PyCall\"  # optional\nENV[\"JULIA_PYTHONCALL_EXE\"] = \"@venv\" # optional","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"By setting the CondaPkg backend to Null, it will never install any Conda packages. In this case, PythonCall will use whichever Python is currently installed and in your PATH. You must have already installed any Python packages that you need.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If python is not in your PATH, you will also need to set JULIA_PYTHONCALL_EXE to its path. Relative paths are resolved relative to the current active project.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If you also use PyCall, you can set JULIA_PYTHONCALL_EXE=@PyCall to use the same Python interpreter. See here.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If you have a Python virtual environment at .venv in your current active project, you can set JULIA_PYTHONCALL_EXE=@venv to use it.","category":"page"},{"location":"pythoncall/#If-you-already-have-a-Conda-environment","page":"Guide","title":"If you already have a Conda environment","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"ENV[\"JULIA_CONDAPKG_BACKEND\"] = \"Current\"\nENV[\"JULIA_CONDAPKG_EXE\"] = \"/path/to/conda\"  # optional","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"The Current backend to CondaPkg will use the currently activated Conda environment instead of creating a new one.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Note that this will still install any required Conda packages into your Conda environment. If you already have your dependencies installed and do not want the environment to be modified, then see the previous section.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If conda, mamba or micromamba is not in your PATH you will also need to set JULIA_CONDAPKG_EXE to its path.","category":"page"},{"location":"pythoncall/#If-you-already-have-Conda,-Mamba-or-MicroMamba","page":"Guide","title":"If you already have Conda, Mamba or MicroMamba","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"ENV[\"JULIA_CONDAPKG_BACKEND\"] = \"System\"\nENV[\"JULIA_CONDAPKG_EXE\"] = \"/path/to/conda\"  # optional","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"The System backend to CondaPkg will use your preinstalled Conda implementation instead of downloading one.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Note that this will still create a new Conda environment and install any required packages into it. If you want to use a pre-existing Conda environment, see the previous section.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If conda, mamba or micromamba is not in your PATH you will also need to set JULIA_CONDAPKG_EXE to its path.","category":"page"},{"location":"pythoncall/#python-deps","page":"Guide","title":"Installing Python packages","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Assuming you haven't opted out, PythonCall uses CondaPkg.jl to automatically install any required Python packages.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"This is as simple as","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"julia> using CondaPkg\n\njulia> # press ] to enter the Pkg REPL\n\npkg> conda add some_package","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"This creates a CondaPkg.toml file in the active project specifying the dependencies, just like a Project.toml specifies Julia dependencies. Commit this file along with the rest of the project so that dependencies are automatically installed for everyone using it.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"To add dependencies to a Julia package, just ensure the package project is activated first.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"See the CondaPkg.jl documentation.","category":"page"},{"location":"pythoncall/#Writing-packages-which-depend-on-PythonCall","page":"Guide","title":"Writing packages which depend on PythonCall","text":"","category":"section"},{"location":"pythoncall/#Example","page":"Guide","title":"Example","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"See https://github.com/cjdoris/Faiss.jl for an example package which wraps the Python FAISS package.","category":"page"},{"location":"pythoncall/#Precompilation","page":"Guide","title":"Precompilation","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"You must not interact with Python during module precompilation. Therefore, instead of","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"module MyModule\n  using PythonCall\n  const foo = pyimport(\"foo\")\n  bar() = foo.bar() # will crash when called\nend","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"you can do the import when the module is loaded, saving the result in a Ref","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"module MyModule\n  using PythonCall\n  const foo = Ref{Py}()\n  function __init__()\n    foo[] = pyimport(\"foo\")\n  end\n  bar() = foo[].bar()\nend","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"or you can perform any imports dynamically","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"module MyModule\n  using PythonCall\n  bar() = pyimport(\"foo\").bar()\nend","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"or if that is too slow, you can cache the import","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"module MyModule\n  using PythonCall\n  bar() = @pyconst(pyimport(\"foo\")).bar()\nend","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"or even cache the imported function","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"module MyModule\n  using PythonCall\n  bar() = @pyconst(pyimport(\"foo\").bar)()\nend","category":"page"},{"location":"pythoncall/#Dependencies","page":"Guide","title":"Dependencies","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If your package depends on some Python packages, you must generate a CondaPkg.toml file. See Installing Python packages.","category":"page"},{"location":"pythoncall/#jl-multi-threading","page":"Guide","title":"Multi-threading","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"From v0.9.22, PythonCall supports multi-threading in Julia and/or Python, with some caveats.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Most importantly, you can only call Python code while Python's Global Interpreter Lock (GIL) is locked by the current thread. Ordinarily, the GIL is locked by the main thread in Julia, so if you want to run Python code on any other thread, you must unlock the GIL from the main thread and then re-lock it while running any Python code on other threads.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"This is made possible by the macros PythonCall.GIL.@unlock and PythonCall.GIL.@lock or the functions PythonCall.GIL.unlock and PythonCall.GIL.lock with this pattern:","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"PythonCall.GIL.@unlock Threads.@threads for i in 1:4\n  PythonCall.GIL.@lock pyimport(\"time\").sleep(5)\nend","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"In the above example, we call time.sleep(5) four times in parallel. If Julia was started with at least four threads (julia -t4) then the above code will take about 5 seconds.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"Both @unlock and @lock are important. If the GIL were not unlocked, then a deadlock would occur when attempting to lock the already-locked GIL from the threads. If the GIL were not re-locked, then Python would crash when interacting with it.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"With multiple Julia threads you need exactly one interactive thread, see the FAQ.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"You can also use multi-threading from Python.","category":"page"},{"location":"pythoncall/#Caveat:-Garbage-collection","page":"Guide","title":"Caveat: Garbage collection","text":"","category":"section"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If Julia's GC collects any Python objects from a thread where the GIL is not currently locked, then those Python objects will not immediately be deleted. Instead they will be queued to be deleted in a later GC pass.","category":"page"},{"location":"pythoncall/","page":"Guide","title":"Guide","text":"If you find you have many Python objects not being deleted, you can call PythonCall.GC.gc() or GC.gc() while the GIL is locked to clear the queue.","category":"page"},{"location":"juliacall-reference/#jl-reference","page":"Reference","title":"JuliaCall API Reference","text":"","category":"section"},{"location":"juliacall-reference/#Constants","page":"Reference","title":"Constants","text":"","category":"section"},{"location":"juliacall-reference/#juliacall.Main","page":"Reference","title":"juliacall.Main","text":"The Julia Main module, as a ModuleValue.\n\nIn interactive scripts, you can use this as the main entry-point to JuliaCall:\n\nfrom juliacall import Main as jl\njl.println(\"Hello, world!\")\n\nIn packages, use newmodule instead.\n\n\n\n\n\n","category":"constant"},{"location":"juliacall-reference/","page":"Reference","title":"Reference","text":"The modules Base, Core and PythonCall are also available.","category":"page"},{"location":"juliacall-reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"juliacall-reference/#juliacall.convert","page":"Reference","title":"juliacall.convert","text":"convert(T, x)\n\nConvert x to a Julia object of type T.\n\nYou can use this to pass an argument to a Julia function of a specific type.\n\n\n\n\n\n","category":"function"},{"location":"juliacall-reference/#juliacall.newmodule","page":"Reference","title":"juliacall.newmodule","text":"newmodule(name)\n\nA new module with the given name.\n\n\n\n\n\n","category":"function"},{"location":"juliacall-reference/#julia-wrappers","page":"Reference","title":"Wrapper types","text":"","category":"section"},{"location":"juliacall-reference/","page":"Reference","title":"Reference","text":"Apart from a few fundamental immutable types, all Julia values are by default converted into Python to some AnyValue object, which wraps the original value, but giving it a Pythonic interface.","category":"page"},{"location":"juliacall-reference/","page":"Reference","title":"Reference","text":"Subclasses of AnyValue provide additional Python semantics. For example a Julia vector is converted to a VectorValue which satisfies the Python sequence interface and behaves very similar to a list.","category":"page"},{"location":"juliacall-reference/","page":"Reference","title":"Reference","text":"There is also a RawValue object, which gives a stricter \"Julia-only\" interface, documented below. These types all inherit from ValueBase:","category":"page"},{"location":"juliacall-reference/","page":"Reference","title":"Reference","text":"ValueBase\nRawValue\nAnyValue\nNumberValue\nComplexValue\nRealValue\nRationalValue\nIntegerValue\nArrayValue\nVectorValue\nDictValue\nSetValue\nIOValue\nBinaryIOValue\nTextIOValue\nModuleValue\nTypeValue","category":"page"},{"location":"juliacall-reference/#juliacall.AnyValue","page":"Reference","title":"juliacall.AnyValue","text":"Wraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), iteration, comparisons, len(x), a in x, dir(x).\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to this table. This is typically a builtin Python type (for immutables) or a subtype of AnyValue.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, _b at the end of an attribute is replaced with ! and _bb is replaced with !!.\n\nMembers\n\n_jl_raw(): Convert to a RawValue. (See also pyjlraw.)\n_jl_display(mime=None): Display the object using Julia's display mechanism.\n_jl_help(mime=None): Display help for the object.\n_jl_call_nogil(*args, **kwargs): Call this with the GIL disabled.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.NumberValue","page":"Reference","title":"juliacall.NumberValue","text":"This wraps any Julia Number value. It is a subclass of numbers.Number and behaves similar to other Python numbers.\n\nThere are also subtypes ComplexValue, RealValue, RationalValue, IntegerValue which wrap values of the corresponding Julia types, and are subclasses of the corresponding numbers ABC.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.ArrayValue","page":"Reference","title":"juliacall.ArrayValue","text":"This wraps any Julia AbstractArray value. It is a subclass of collections.abc.Collection.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nIf the array is strided and its eltype is supported (i.e. Bool, IntXX, UIntXX, FloatXX, Complex{FloatXX}, Ptr{Cvoid} or Tuple or NamedTuple of these) then it supports the buffer protocol and the numpy array interface. This means that numpy.asarray(this) will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy __array__ method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, numpy.asarray(this) is a copy of the original array.\n\nMembers\n\nndim: The number of dimensions.\nshape: Tuple of lengths in each dimension.\ncopy(): A copy of the array.\nreshape(shape): A reshaped view of the array.\nto_numpy(dtype=None, copy=True, order=\"K\"): Convert to a numpy array.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.VectorValue","page":"Reference","title":"juliacall.VectorValue","text":"This wraps any Julia AbstractVector value. It is a subclass of juliacall.ArrayValue and collections.abc.MutableSequence and behaves similar to a Python list.\n\nMembers\n\nresize(size): Change the length of the vector.\nsort(reverse=False, key=None): Sort the vector in-place.\nreverse(): Reverse the vector.\nclear(): Empty the vector.\ninsert(index, value): Insert the value at the given index.\nappend(value): Append the value to the end of the vector.\nextend(values): Append the values to the end of the vector.\npop(index=-1): Remove and return the item at the given index.\nremove(value): Remove the first item equal to the value.\nindex(value): The index of the first item equal to the value.\ncount(value): The number of items equal to the value.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.DictValue","page":"Reference","title":"juliacall.DictValue","text":"This wraps any Julia AbstractDict value. It is a subclass of collections.abc.Mapping and behaves similar to a Python dict.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.SetValue","page":"Reference","title":"juliacall.SetValue","text":"This wraps any Julia AbstractSet value. It is a subclass of collections.abc.Set and behaves similar to a Python set.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.IOValue","page":"Reference","title":"juliacall.IOValue","text":"This wraps any Julia IO value. It is a subclass of io.IOBase and behaves like Python files.\n\nThere are also subtypes BinaryIOValue and TextIOValue, which are subclasses of io.BufferedIOBase (buffered bytes) and io.TextIOBase (text).\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.ModuleValue","page":"Reference","title":"juliacall.ModuleValue","text":"This wraps any Julia Module value.\n\nIt is the same as AnyValue except for one additional convenience method:\n\nseval([module=self], code): Evaluates the given code (a string) in the given module.\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.TypeValue","page":"Reference","title":"juliacall.TypeValue","text":"This wraps any Julia Type value.\n\nIt is the same as AnyValue except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n\n\n\n\n\n","category":"class"},{"location":"juliacall-reference/#juliacall.RawValue","page":"Reference","title":"juliacall.RawValue","text":"Wraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), len(x), dir(x).\n\nThis is very similar to AnyValue except that indexing, calling, etc. will always return a RawValue.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\nMembers\n\n_jl_any(): Convert to a AnyValue (or subclass). (See also pyjl.)\n_jl_call_nogil(*args, **kwargs): Call this with the GIL disabled.\n\n\n\n\n\n","category":"class"},{"location":"juliacall/#The-Python-module-JuliaCall","page":"Guide","title":"The Python module JuliaCall","text":"","category":"section"},{"location":"juliacall/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"It's as simple as","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"pip install juliacall","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Developers may wish to clone the repo (https://github.com/JuliaPy/PythonCall.jl) directly and pip install the module in editable mode. You should add \"dev\":true, \"path\":\"../..\" to pysrc/juliacall/juliapkg.json to ensure you use the development version of PythonCall in conjunction with JuliaCall.","category":"page"},{"location":"juliacall/#Getting-started","page":"Guide","title":"Getting started","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"For interactive or scripting use, the simplest way to get started is:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"from juliacall import Main as jl","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"This loads a single variable jl which represents the Main module in Julia, from which all of Julia's functionality is available:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"jl.println(\"Hello from Julia!\")\n# Hello from Julia!\nx = jl.rand(range(10), 3, 5)\nx._jl_display()\n# 3×5 Matrix{Int64}:\n#  8  1  7  0  6\n#  9  2  1  4  0\n#  1  8  5  4  0\nimport numpy\nnumpy.sum(x, axis=0)\n# array([18, 11, 13,  8,  6], dtype=int64)","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"In this example:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"We called the jl.println function to print a message.\nWe called the jl.rand function to generate an array of random integers. Note that the first argument is range(10) which is converted to 0:9 in Julia.\nWe called its special _jl_display() to show it using Julia's display mechanism.\nWe called the numpy.sum function to sum each column of x. This automatically converted x to a NumPy array. (We could have done jl.sum(x, dims=1) too.)","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"If you are writing a package which uses Julia, then to avoid polluting the global Main namespace you instead should start with:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"import juliacall\njl = juliacall.newmodule(\"SomeName\")","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Julia modules have a special method seval which will evaluate a given piece of code given as a string in the module. This is most frequently used to import modules:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"from array import array\njl.seval(\"using Statistics\")\nx = array('i', [1, 2, 3])\njl.mean(x)\n# 2.0\ny = array('i', [2,4,8])\njl.cor(x, y)\n# 0.9819805060619657","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"What to read next:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"The main functionality of this package is in AnyValue objects, which represent Julia objects, documented here.\nIf you need to install Julia packages, read here.\nWhen you call a Julia function, such as jl.rand(...) in the above example, its arguments are converted to Julia according to this table and its return value is converted to Python according to this table.","category":"page"},{"location":"juliacall/#julia-deps","page":"Guide","title":"Managing Julia dependencies","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"By default JuliaCall manages its Julia dependencies using JuliaPkg.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"It will automatically download a suitable version of Julia if required.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"A Julia environment is also created, activated and populated with any required packages. If you are in a virtual or Conda environment, the environment is put there. Otherwise a global environment is used at ~/.julia/environments/pyjuliapkg.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"If your project requires any Julia packages, or a particular version of Julia itself, then create a file called juliapkg.json in your package. For example: Here is an example:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"{\n    \"julia\": \"1.5\",\n    \"packages\": {\n        \"Example\": {\n            \"uuid\": \"7876af07-990d-54b4-ab0e-23690620f79a\",\n            \"version\": \"0.5, 0.6\"\n        }\n    }\n}","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Alternatively you can use add, rm, etc. from JuliaPkg to edit this file.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"See JuliaPkg for more details.","category":"page"},{"location":"juliacall/#Using-existing-environments","page":"Guide","title":"Using existing environments","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"It's possible to override the defaults and disable JuliaPkg entirely by setting the PYTHON_JULIACALL_EXE and PYTHON_JULIACALL_PROJECT options (both must be set together). This is particularly useful when using shared environments on HPC systems that may be readonly. Note that the project set in PYTHON_JULIACALL_PROJECT must already have PythonCall.jl installed and it must match the JuliaCall version, otherwise loading Julia will fail.","category":"page"},{"location":"juliacall/#julia-config","page":"Guide","title":"Configuration","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Some features of the Julia process, such as the optimization level or number of threads, may be configured in two ways:","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"As an -X argument to Python, such as -X juliacall-optlevel=3; or\nAs an environment variable, such as PYTHON_JULIACALL_OPTLEVEL=3.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"-X option Environment Variable Description\n-X juliacall-home=<dir> PYTHON_JULIACALL_BINDIR=<dir> The directory containing the julia executable.\n-X juliacall-check-bounds=<yes|no|auto> PYTHON_JULIACALL_CHECK_BOUNDS=<yes|no|auto> Enable or disable bounds checking.\n-X juliacall-compile=<yes|no|all|min> PYTHON_JULIACALL_COMPILE=<yes|no|all|min> Enable or disable JIT compilation.\n-X juliacall-compiled-modules=<yes|no> PYTHON_JULIACALL_COMPILED_MODULES=<yes|no> Enable or disable incrementally compiling modules.\n-X juliacall-depwarn=<yes|no|error> PYTHON_JULIACALL_DEPWARN=<yes|no|error> Enable or disable deprecation warnings.\n-X juliacall-handle-signals=<yes|no> PYTHON_JULIACALL_HANDLE_SIGNALS=<yes|no> Enable or disable Julia signal handling.\n-X juliacall-inline=<yes|no> PYTHON_JULIACALL_INLINE=<yes|no> Enable or disable inlining.\n-X juliacall-min-optlevel=<0|1|2|3> PYTHON_JULIACALL_MIN_OPTLEVEL=<0|1|2|3> Optimization level.\n-X juliacall-optimize=<0|1|2|3> PYTHON_JULIACALL_OPTIMIZE=<0|1|2|3> Minimum optimization level.\n-X juliacall-procs=<N|auto> PYTHON_JULIACALL_PROCS=<N|auto> Launch N local worker process.\n-X juliacall-startup-file=<yes|no> PYTHON_JULIACALL_STARTUP_FILE=<yes|no> Enable or disable your startup.jl file.\n-X juliacall-sysimage=<file> PYTHON_JULIACALL_SYSIMAGE=<file> Use the given system image.\n-X juliacall-threads=<N|auto> PYTHON_JULIACALL_THREADS=<N|auto> Launch N threads.\n-X juliacall-warn-overwrite=<yes|no> PYTHON_JULIACALL_WARN_OVERWRITE=<yes|no> Enable or disable method overwrite warnings.\n-X juliacall-autoload-ipython-extension=<yes|no> PYTHON_JULIACALL_AUTOLOAD_IPYTHON_EXTENSION=<yes|no> Enable or disable IPython extension autoloading.\n-X juliacall-heap-size-hint=<N> PYTHON_JULIACALL_HEAP_SIZE_HINT=<N> Hint for initial heap size in bytes.\n-X juliacall-exe=<file> PYTHON_JULIACALL_EXE=<file> Path to Julia binary to use (overrides JuliaPkg).\n-X juliacall-project=<dir> PYTHON_JULIACALL_PROJECT=<dir> Path to the Julia project to use (overrides JuliaPkg).","category":"page"},{"location":"juliacall/#py-multi-threading","page":"Guide","title":"Multi-threading","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"From v0.9.22, JuliaCall supports multi-threading in Julia and/or Python, with some caveats.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Most importantly, you can only call Python code while Python's Global Interpreter Lock (GIL) is locked by the current thread. You can use JuliaCall from any Python thread, and the GIL will be locked whenever any JuliaCall function is used. However, to leverage the benefits of multi-threading, you can unlock the GIL while executing any Julia code that does not interact with Python.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"The simplest way to do this is using the _jl_call_nogil method on Julia functions to call the function with the GIL unlocked.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"from concurrent.futures import ThreadPoolExecutor, wait\nfrom juliacall import Main as jl\npool = ThreadPoolExecutor(4)\nfs = [pool.submit(jl.Libc.systemsleep._jl_call_nogil, 5) for _ in range(4)]\nwait(fs)","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"In the above example, we call Libc.systemsleep(5) on four threads. Because we called it with _jl_call_nogil, the GIL was unlocked, allowing the threads to run in parallel, taking about 5 seconds in total.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"If we did not use _jl_call_nogil (i.e. if we did pool.submit(jl.Libc.systemsleep, 5)) then the above code will take 20 seconds because the sleeps run one after another.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"It is very important that any function called with _jl_call_nogil does not interact with Python at all unless it re-locks the GIL first, such as by using PythonCall.GIL.@lock.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"You can also use multi-threading from Julia.","category":"page"},{"location":"juliacall/#Caveat:-Julia's-task-scheduler","page":"Guide","title":"Caveat: Julia's task scheduler","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"If you try the above example with a Julia function that yields to the task scheduler, such as sleep instead of Libc.systemsleep, then you will likely experience a hang.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"In this case, you need to yield back to Julia's scheduler periodically to allow the task to continue. You can use the following pattern instead of wait(fs):","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"jl_yield = getattr(jl, \"yield\")\nwhile True:\n  # yield to Julia's task scheduler\n  jl_yield()\n  # wait for up to 0.1 seconds for the threads to finish\n  state = wait(fs, timeout=0.1)\n  # if they finished then stop otherwise try again\n  if not state.not_done:\n    break","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Set the timeout parameter smaller to let Julia's scheduler cycle more frequently.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Future versions of JuliaCall may provide tooling to make this simpler.","category":"page"},{"location":"juliacall/#py-multi-threading-signal-handling","page":"Guide","title":"Caveat: Signal handling","text":"","category":"section"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"We recommend setting PYTHON_JULIACALL_HANDLE_SIGNALS=yes before importing JuliaCall with multiple threads.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"This is because Julia intentionally causes segmentation faults as part of the GC safepoint mechanism. If unhandled, these segfaults will result in termination of the process. See discussion here for more information.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Note however that this interferes with Python's own signal handling, so for example Ctrl-C will not raise KeyboardInterrupt.","category":"page"},{"location":"juliacall/","page":"Guide","title":"Guide","text":"Future versions of JuliaCall may make this the default behaviour when using multiple threads.","category":"page"},{"location":"conversion-to-python/#jl2py","page":"Julia to Python","title":"Conversion to Python","text":"","category":"section"},{"location":"conversion-to-python/#jl2py-conversion","page":"Julia to Python","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"The following table specifies the conversion rules used whenever converting a Julia object to a Python object.","category":"page"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"From Julia, this occurs explicitly with Py(x) or implicitly when passing Julia objects as the argument to a Python function. To avoid this automatic conversion, the user can convert objects explicitly, such as by calling pylist or pydict.","category":"page"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"From Python, this occurs when converting the return value of a Julia function.","category":"page"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"From To\nAny Python object type (Py, PyList, etc.) itself\nNothing None\nBool bool\nInteger int\nRational{<:Integer} fractions.Fraction\nFloat64, Float32, Float16 float\nComplex{Float64}, Complex{Float32}, Complex{Float16} complex\nAbstractString, AbstractChar str\nBase.CodeUnits{UInt8} (e.g. b\"example\") bytes\nTuple, Pair tuple\nAbstractRange{<:Integer} range\nDates.Date datetime.date\nDates.Time datetime.time\nDates.DateTime datetime.datetime\nDates.Second, Dates.Millisecond, Dates.Microsecond, Dates.Nanosecond datetime.timedelta\nNumber juliacall.NumberValue, juliacall.ComplexValue, etc.\nAbstractArray juliacall.ArrayValue, juliacall.VectorValue\nAbstractDict juliacall.DictValue\nAbstractSet juliacall.SetValue\nIO juliacall.BufferedIOValue\nModule juliacall.ModuleValue\nType juliacall.TypeValue\nAnything else juliacall.AnyValue","category":"page"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"See here for an explanation of the juliacall.*Value wrapper types.","category":"page"},{"location":"conversion-to-python/#jl2py-conversion-custom","page":"Julia to Python","title":"Custom rules","text":"","category":"section"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"You may define a new conversion rule for your new type T by overloading Py(::T).","category":"page"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"If T is a wrapper type (such as PyList) where Py(x) simply returns the stored Python object, then also define ispy(::T) = true.","category":"page"},{"location":"conversion-to-python/#PythonCall.ispy","page":"Julia to Python","title":"PythonCall.ispy","text":"ispy(x)\n\nTrue if x is a Python object.\n\nThis includes Py and Python wrapper types such as PyList.\n\n\n\n\n\n","category":"function"},{"location":"conversion-to-python/","page":"Julia to Python","title":"Julia to Python","text":"Alternatively, if you define a wrapper type (a subtype of juliacall.AnyValue) then you may instead define pyjltype(::T) to be that type.","category":"page"},{"location":"conversion-to-python/#PythonCall.pyjltype","page":"Julia to Python","title":"PythonCall.pyjltype","text":"pyjltype(x)\n\nThe subtype of juliacall.AnyValue which the Julia object x is wrapped as by pyjl(x).\n\nOverload pyjltype(::T) to define a custom conversion for your type T.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Compatibility-Tools","page":"Compatibility Tools","title":"Compatibility Tools","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some packages require a little extra help to work nicely with PythonCall.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some of these are \"fixes\" that are silently applied for you, and some are just extra functions to bridge a gap. We aim to keep these as minimal as possible.","category":"page"},{"location":"compat/#Python-standard-library","page":"Compatibility Tools","title":"Python standard library","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Whenever a Python exception is displayed by Julia, sys.last_traceback and friends are set. This allows the post-mortem debugger pdb.pm() to work. Disable by setting PythonCall.CONFIG.auto_sys_last_traceback = false.","category":"page"},{"location":"compat/#Julia-standard-library","page":"Compatibility Tools","title":"Julia standard library","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Python objects can be serialised with the Serialization stdlib. This uses pickle library under the hood. You can opt into using dill instead by setting the environment variable JULIA_PYTHONCALL_PICKLE=\"dill\".","category":"page"},{"location":"compat/#Tabular-data-/-Pandas","page":"Compatibility Tools","title":"Tabular data / Pandas","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The abstract type PyTable is for wrapper types around Python tables, providing the Tables.jl interface. PyTable(x) is shorthand for pyconvert(PyTable, x).","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The subtype PyPandasDataFrame wraps a pandas.DataFrame.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"For example, if x is a pandas.DataFrame then PyTable(x) is a PyPandasDataFrame and DataFrame(PyTable(x)) is a DataFrame.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"In the other direction, the following functions can be used to convert any Tables.jl-compatible table to a Python table.","category":"page"},{"location":"compat/#PythonCall.pytable","page":"Compatibility Tools","title":"PythonCall.pytable","text":"pytable(src, format=:pandas; ...)\n\nConstruct a Python table from the Tables.jl-compatible table src.\n\nThe format controls the type of the resulting table, and is one of:\n\n:pandas: A pandas.DataFrame. Keyword arguments are passed to the DataFrame constructor.\n:columns: A dict mapping column names to columns.\n:rows: A list of rows, which are namedtuples.\n:rowdicts: A list of rows, which are dicts.\n\n\n\n\n\n","category":"function"},{"location":"compat/#MatPlotLib-/-PyPlot-/-Seaborn","page":"Compatibility Tools","title":"MatPlotLib / PyPlot / Seaborn","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"MatPlotLib figures can be shown with Julia's display mechanism, like display(fig) or display(mime, fig).","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"This means that if you return a figure from a Jupyter or Pluto notebook cell, it will be shown. You can call display(plt.gcf()) to display the current figure.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"We also provide a simple MatPlotLib backend: mpl.use(\"module://juliacall.matplotlib\"). Now you can call plt.show() to display the figure with Julia's display mechanism. You can specify the format like plt.show(format=\"png\").","category":"page"},{"location":"compat/#Python-GUIs-(including-MatPlotLib)","page":"Compatibility Tools","title":"Python GUIs (including MatPlotLib)","text":"","category":"section"},{"location":"compat/#Event-loops","page":"Compatibility Tools","title":"Event loops","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If for example you wish to use PyPlot in interactive mode (matplotlib.pyplot.ion()) then activating the correct event loop will allow it to work.","category":"page"},{"location":"compat/#PythonCall.event_loop_on","page":"Compatibility Tools","title":"PythonCall.event_loop_on","text":"event_loop_on(g::Symbol; interval=0.04, fix=false)\n\nActivate an event loop for the GUI framework g, so that the framework can run in the background of a Julia session.\n\nThe event loop runs every interval seconds. If fix is true and g is a Qt framework, then fix_qt_plugin_path is called.\n\nSupported values of g (and the Python module they relate to) are: :pyqt4 (PyQt4), :pyqt5 (PyQt5), :pyside (PySide), :pyside2 (PySide2), :pyside6 (PySide6), :gtk (gtk), :gtk3 (gi), :wx (wx), :tkinter (tkinter).\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.event_loop_off","page":"Compatibility Tools","title":"PythonCall.event_loop_off","text":"event_loop_off(g::Symbol)\n\nTerminate the event loop g if it is running.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Qt-path-fix","page":"Compatibility Tools","title":"Qt path fix","text":"","category":"section"},{"location":"compat/#PythonCall.fix_qt_plugin_path","page":"Compatibility Tools","title":"PythonCall.fix_qt_plugin_path","text":"fix_qt_plugin_path()\n\nTry to set the QT_PLUGIN_PATH environment variable in Python, if not already set.\n\nThis fixes the problem that Qt does not know where to find its qt.conf file, because it always looks relative to sys.executable, which can be the Julia executable not the Python one when using this package.\n\nIf CONFIG.auto_fix_qt_plugin_path is true, then this is run automatically before PyQt4, PyQt5, PySide, PySide2 or PySide6 are imported.\n\n\n\n\n\n","category":"function"},{"location":"compat/#IPython","page":"Compatibility Tools","title":"IPython","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The juliacall IPython extension adds these features to your IPython session:","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The line magic %julia code executes the given Julia code in-line.\nThe cell magic %%julia executes a cell of Julia code.\nJulia's stdout and stderr are redirected to IPython.\nCalling display(x) from Julia will display x in IPython.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The extension is experimental and unstable - the API can change at any time.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"You can explicitly enable the extension with %load_ext juliacall, but it will automatically be loaded if juliacall is imported and IPython is detected. You can disable this behavior with an environment variable.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"The %%julia cell magic can synchronise variables between Julia and Python by listing them on the first line:","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"In [1]: %load_ext juliacall\n\nIn [2]: x = 2\n\nIn [3]: y = 8\n\nIn [4]: %%julia x y z\n   ...: z = \"$x^$y = $(x^y)\";\n   ...:\n   ...:\n\nIn [5]: z\nOut[5]: '2^8 = 256'","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Also see the IPython docs for more information on extensions.","category":"page"},{"location":"compat/#Asynchronous-Julia-code-(including-Makie)","page":"Compatibility Tools","title":"Asynchronous Julia code (including Makie)","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Asynchronous Julia code will not normally run while Python is executing, unless it is in a separate thread.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"This can be fixed by calling jl.yield() periodically from Python code, allowing the Julia scheduler to run.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"When working at the Python REPL, you may call juliacall.interactive() which will allow Julia async code to run while the prompt is showing. This will allow interactive plots such as Makie to work.","category":"page"},{"location":"pythoncall-reference/#py-reference","page":"Reference","title":"PythonCall API Reference","text":"","category":"section"},{"location":"pythoncall-reference/#Py-objects","page":"Reference","title":"Py objects","text":"","category":"section"},{"location":"pythoncall-reference/#PythonCall.Py","page":"Reference","title":"PythonCall.Py","text":"Py(x)\n\nConvert x to a Python object, of type Py.\n\nConversion happens according to these rules.\n\nSuch an object supports attribute access (obj.attr), indexing (obj[idx]), calling (obj(arg1, arg2)), iteration (for x in obj), arithmetic (obj + obj2) and comparison (obj > obj2), among other things. These operations convert all their arguments to Py and return Py.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.pybuiltins","page":"Reference","title":"PythonCall.pybuiltins","text":"pybuiltins\n\nAn object whose fields are the Python builtins, of type Py.\n\nFor example pybuiltins.None, pybuiltins.int, pybuiltins.ValueError.\n\n\n\n\n\n","category":"module"},{"location":"pythoncall-reference/#Constructors","page":"Reference","title":"Constructors","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions construct Python objects of builtin types from Julia values.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pybool","page":"Reference","title":"PythonCall.pybool","text":"pybool(x)\n\nConvert x to a Python bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycollist","page":"Reference","title":"PythonCall.pycollist","text":"pycollist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of columns.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pybytes","page":"Reference","title":"PythonCall.pybytes","text":"pybytes(x)\n\nConvert x to a Python bytes.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycomplex","page":"Reference","title":"PythonCall.pycomplex","text":"pycomplex(x=0.0)\npycomplex(re, im)\n\nConvert x to a Python complex, or create one from given real and imaginary parts.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydict","page":"Reference","title":"PythonCall.pydict","text":"pydict(x)\npydict(; x...)\npydict(x::Pair...)\n\nConvert x to a Python dict. In the second form, the keys are strings.\n\nIf x is a Python object, this is equivalent to dict(x) in Python. Otherwise x must iterate over key-value pairs.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyfloat","page":"Reference","title":"PythonCall.pyfloat","text":"pyfloat(x=0.0)\n\nConvert x to a Python float.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyfrozenset","page":"Reference","title":"PythonCall.pyfrozenset","text":"pyfrozenset(x=())\n\nConvert x to a Python frozenset.\n\nIf x is a Python object, this is equivalent to frozenset(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyint","page":"Reference","title":"PythonCall.pyint","text":"pyint(x=0)\n\nConvert x to a Python int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pylist","page":"Reference","title":"PythonCall.pylist","text":"pylist(x=())\n\nConvert x to a Python list.\n\nIf x is a Python object, this is equivalent to list(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyrange","page":"Reference","title":"PythonCall.pyrange","text":"pyrange([[start], [stop]], [step])\n\nConstruct a Python range. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyrowlist","page":"Reference","title":"PythonCall.pyrowlist","text":"pyrowlist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of rows.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyset","page":"Reference","title":"PythonCall.pyset","text":"pyset(x=())\n\nConvert x to a Python set.\n\nIf x is a Python object, this is equivalent to set(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyslice","page":"Reference","title":"PythonCall.pyslice","text":"pyslice([start], stop, [step])\n\nConstruct a Python slice. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pystr","page":"Reference","title":"PythonCall.pystr","text":"pystr(x)\n\nConvert x to a Python str.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pytuple","page":"Reference","title":"PythonCall.pytuple","text":"pytuple(x=())\n\nConvert x to a Python tuple.\n\nIf x is a Python object, this is equivalent to tuple(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Builtins","page":"Reference","title":"Builtins","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions mimic the Python builtin functions or keywords of the same name.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pyall","page":"Reference","title":"PythonCall.pyall","text":"pyall(x)\n\nEquivalent to all(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyany","page":"Reference","title":"PythonCall.pyany","text":"pyany(x)\n\nEquivalent to any(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyascii","page":"Reference","title":"PythonCall.pyascii","text":"pyascii(x)\n\nEquivalent to ascii(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycall","page":"Reference","title":"PythonCall.pycall","text":"pycall(f, args...; kwargs...)\n\nCall the Python object f with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycallable","page":"Reference","title":"PythonCall.pycallable","text":"pycallable(x)\n\nEquivalent to callable(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycompile","page":"Reference","title":"PythonCall.pycompile","text":"pycompile(...)\n\nEquivalent to compile(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycontains","page":"Reference","title":"PythonCall.pycontains","text":"pycontains(x, v)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydelattr","page":"Reference","title":"PythonCall.pydelattr","text":"pydelattr(x, k)\n\nEquivalent to delattr(x, k) or del x.k in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydelitem","page":"Reference","title":"PythonCall.pydelitem","text":"pydelitem(x, k)\n\nEquivalent to delitem(x, k) or del x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydir","page":"Reference","title":"PythonCall.pydir","text":"pydir(x)\n\nEquivalent to dir(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyeval","page":"Reference","title":"PythonCall.pyeval","text":"pyeval([T=Py], code, globals, locals=nothing)\n\nEvaluate the given Python code, returning the result as a T.\n\nIf globals is a Module, then a persistent dict unique to that module is used.\n\nBy default the code runs in global scope (i.e. locals===globals). To use a temporary local scope, set locals to (), or to a NamedTuple of variables to include in the scope.\n\nSee also @pyeval.\n\nExamples\n\nThe following computes 1.1+2.2 in the Main module as a Float64:\n\npyeval(Float64, \"x+y\", Main, (x=1.1, y=2.2))  # returns 3.3\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.@pyeval","page":"Reference","title":"PythonCall.@pyeval","text":"@pyeval [inputs =>] code [=> T]\n\nEvaluate the given code in a new local scope and return the answer as a T.\n\nThe global scope is persistent and unique to the current module.\n\nThe code must be a literal string or command.\n\nThe inputs is a tuple of inputs of the form v=expr to be included in the local scope. Only v is required, expr defaults to v.\n\nExamples\n\nThe following computes 1.1+2.2 and returns a Float64:\n\n@pyeval (x=1.1, y=2.2) => `x+y` => Float64  # returns 3.3\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#PythonCall.pyexec","page":"Reference","title":"PythonCall.pyexec","text":"pyexec([T=Nothing], code, globals, locals=nothing)\n\nExecute the given Python code.\n\nIf globals is a Module, then a persistent dict unique to that module is used.\n\nBy default the code runs in global scope (i.e. locals===globals). To use a temporary local scope, set locals to (), or to a NamedTuple of variables to include in the scope.\n\nIf T==Nothing then returns nothing. Otherwise T must be a concrete NamedTuple type and the corresponding items from locals are extracted and returned.\n\nSee also @pyexec.\n\nExamples\n\nThe following computes 1.1+2.2 in the Main module as a Float64:\n\npyexec(@NamedTuple{ans::Float64}, \"ans=x+y\", Main, (x=1.1, y=2.2))  # returns (ans = 3.3,)\n\nMarking variables as global saves them into the module scope, so that they are available in subsequent invocations:\n\npyexec(\"global x; x=12\", Main)\npyeval(Int, \"x\", Main)  # returns 12\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.@pyexec","page":"Reference","title":"PythonCall.@pyexec","text":"@pyexec [inputs =>] code [=> outputs]\n\nExecute the given code in a new local scope.\n\nThe global scope is persistent and unique to the current module.\n\nThe code must be a literal string or command.\n\nThe inputs is a tuple of inputs of the form v=expr to be included in the local scope. Only v is required, expr defaults to v.\n\nThe outputs is a tuple of outputs of the form x::T=v, meaning that v is extracted from locals, converted to T and assigned to x. Only x is required: T defaults to Py and v defaults to x.\n\nExamples\n\nThe following computes 1.1+2.2 and assigns its value to ans as a Float64:\n\n@pyexec (x=1.1, y=2.2) => `ans=x+y` => ans::Float64  # returns 3.3\n\nMarking variables as global saves them into the module scope, so that they are available in subsequent invocations:\n\n@pyexec `global x; x=12`\n@pyeval `x` => Int  # returns 12\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#PythonCall.pygetattr","page":"Reference","title":"PythonCall.pygetattr","text":"pygetattr(x, k, [d])\n\nEquivalent to getattr(x, k) or x.k in Python.\n\nIf d is specified, it is returned if the attribute does not exist.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pygetitem","page":"Reference","title":"PythonCall.pygetitem","text":"pygetitem(x, k, [d])\n\nEquivalent x[k] in Python.\n\nIf d is specified, it is returned if the item does not exist (i.e. if x[k] raises a KeyError or IndexError).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyhasattr","page":"Reference","title":"PythonCall.pyhasattr","text":"pyhasattr(x, k)\n\nEquivalent to hasattr(x, k) in Python.\n\nTests if getattr(x, k) raises an AttributeError.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyhasitem","page":"Reference","title":"PythonCall.pyhasitem","text":"pyhasitem(x, k)\n\nTest if pygetitem(x, k) raises a KeyError or AttributeError.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyhash","page":"Reference","title":"PythonCall.pyhash","text":"pyhash(x)\n\nEquivalent to hash(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyhelp","page":"Reference","title":"PythonCall.pyhelp","text":"pyhelp([x])\n\nEquivalent to help(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyimport","page":"Reference","title":"PythonCall.pyimport","text":"pyimport(m)\npyimport(m => k)\npyimport(m => (k1, k2, ...))\npyimport(m1, m2, ...)\n\nImport a module m, or an attribute k, or a tuple of attributes.\n\nIf several arguments are given, return the results of importing each one in a tuple.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyin","page":"Reference","title":"PythonCall.pyin","text":"pyin(v, x)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyis","page":"Reference","title":"PythonCall.pyis","text":"pyis(x, y)\n\nTrue if x and y are the same Python object. Equivalent to x is y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyisinstance","page":"Reference","title":"PythonCall.pyisinstance","text":"pyisinstance(x, t)\n\nTest if x is of type t. Equivalent to isinstance(x, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyissubclass","page":"Reference","title":"PythonCall.pyissubclass","text":"pyissubclass(s, t)\n\nTest if s is a subclass of t. Equivalent to issubclass(s, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyiter","page":"Reference","title":"PythonCall.pyiter","text":"pyiter(x)\n\nEquivalent to iter(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pylen","page":"Reference","title":"PythonCall.pylen","text":"pylen(x)\n\nThe length of x. Equivalent to len(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pynext","page":"Reference","title":"PythonCall.pynext","text":"pynext(x)\n\nEquivalent to next(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyprint","page":"Reference","title":"PythonCall.pyprint","text":"pyprint(...)\n\nEquivalent to print(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyrepr","page":"Reference","title":"PythonCall.pyrepr","text":"pyrepr(x)\n\nEquivalent to repr(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pysetattr","page":"Reference","title":"PythonCall.pysetattr","text":"pysetattr(x, k, v)\n\nEquivalent to setattr(x, k, v) or x.k = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pysetitem","page":"Reference","title":"PythonCall.pysetitem","text":"pysetitem(x, k, v)\n\nEquivalent to setitem(x, k, v) or x[k] = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pytype-Tuple{Any}","page":"Reference","title":"PythonCall.pytype","text":"pytype(x)\n\nThe Python type of x.\n\n\n\n\n\n","category":"method"},{"location":"pythoncall-reference/#PythonCall.pywith","page":"Reference","title":"PythonCall.pywith","text":"pywith(f, o, d=nothing)\n\nEquivalent to with o as x: f(x) in Python, where x is a Py.\n\nOn success, the value of f(x) is returned.\n\nIf an exception occurs but is suppressed then d is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Conversion-to-Julia","page":"Reference","title":"Conversion to Julia","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions convert Python values to Julia values, using the rules documented here.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pyconvert","page":"Reference","title":"PythonCall.pyconvert","text":"pyconvert(T, x, [d])\n\nConvert the Python object x to a T.\n\nIf d is specified, it is returned on failure instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.@pyconvert","page":"Reference","title":"PythonCall.@pyconvert","text":"@pyconvert(T, x, [onfail])\n\nConvert the Python object x to a T.\n\nOn failure, evaluates to onfail, which defaults to return pyconvert_unconverted() (mainly useful for writing conversion rules).\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#Wrap-Julia-values","page":"Reference","title":"Wrap Julia values","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions explicitly wrap Julia values into Python objects, documented here.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"As documented here, Julia values are wrapped like this automatically on conversion to Python, unless the value is immutable and has a corresponding Python type.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pyjl","page":"Reference","title":"PythonCall.pyjl","text":"pyjl([t=pyjltype(x)], x)\n\nCreate a Python object wrapping the Julia object x.\n\nIf x is mutable, then mutating the returned object also mutates x, and vice versa.\n\nIts Python type is normally inferred from the type of x, but can be specified with t.\n\nFor example if x is an AbstractVector then the object will have type juliacall.VectorValue. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.\n\nTo define a custom conversion for your type T, overload pyjltype(::T).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyjlraw","page":"Reference","title":"PythonCall.pyjlraw","text":"pyjlraw(v)\n\nCreate a Python object wrapping the Julia object x.\n\nIt has type juliacall.RawValue. This has a much more rigid \"Julian\" interface than pyjl(v). For example, accessing attributes or calling this object will always return a RawValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyisjl","page":"Reference","title":"PythonCall.pyisjl","text":"pyisjl(x)\n\nTest whether x is a wrapped Julia value, namely an instance of juliacall.ValueBase.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyjlvalue","page":"Reference","title":"PythonCall.pyjlvalue","text":"pyjlvalue(x)\n\nExtract the value from the wrapped Julia value x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pybinaryio","page":"Reference","title":"PythonCall.pybinaryio","text":"pybinaryio(io::IO)\n\nWrap io as a Python binary IO object.\n\nThis is the default behaviour of Py(io).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pytextio","page":"Reference","title":"PythonCall.pytextio","text":"pytextio(io::IO)\n\nWrap io as a Python text IO object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Arithmetic","page":"Reference","title":"Arithmetic","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions are equivalent to the corresponding Python arithmetic operators.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1)+Py(2), Py(1)+2, pyadd(1, 2), pyadd(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pyneg","page":"Reference","title":"PythonCall.pyneg","text":"pyneg(x)\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pypos","page":"Reference","title":"PythonCall.pypos","text":"pypos(x)\n\nEquivalent to +x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyabs","page":"Reference","title":"PythonCall.pyabs","text":"pyabs(x)\n\nEquivalent to abs(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyinv","page":"Reference","title":"PythonCall.pyinv","text":"pyinv(x)\n\nEquivalent to ~x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyindex","page":"Reference","title":"PythonCall.pyindex","text":"pyindex(x)\n\nConvert x losslessly to an int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyadd","page":"Reference","title":"PythonCall.pyadd","text":"pyadd(x, y)\n\nEquivalent to x + y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pysub","page":"Reference","title":"PythonCall.pysub","text":"pysub(x, y)\n\nEquivalent to x - y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pymul","page":"Reference","title":"PythonCall.pymul","text":"pymul(x, y)\n\nEquivalent to x * y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pymatmul","page":"Reference","title":"PythonCall.pymatmul","text":"pymatmul(x, y)\n\nEquivalent to x @ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pypow","page":"Reference","title":"PythonCall.pypow","text":"pypow(x, y, z=None)\n\nEquivalent to x ** y or pow(x, y, z) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyfloordiv","page":"Reference","title":"PythonCall.pyfloordiv","text":"pyfloordiv(x, y)\n\nEquivalent to x // y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pytruediv","page":"Reference","title":"PythonCall.pytruediv","text":"pytruediv(x, y)\n\nEquivalent to x / y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pymod","page":"Reference","title":"PythonCall.pymod","text":"pymod(x, y)\n\nEquivalent to x % y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydivmod","page":"Reference","title":"PythonCall.pydivmod","text":"pydivmod(x, y)\n\nEquivalent to divmod(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pylshift","page":"Reference","title":"PythonCall.pylshift","text":"pylshift(x, y)\n\nEquivalent to x << y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyrshift","page":"Reference","title":"PythonCall.pyrshift","text":"pyrshift(x, y)\n\nEquivalent to x >> y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyand","page":"Reference","title":"PythonCall.pyand","text":"pyand(x, y)\n\nEquivalent to x & y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyxor","page":"Reference","title":"PythonCall.pyxor","text":"pyxor(x, y)\n\nEquivalent to x ^ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyor","page":"Reference","title":"PythonCall.pyor","text":"pyor(x, y)\n\nEquivalent to x | y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyiadd","page":"Reference","title":"PythonCall.pyiadd","text":"pyiadd(x, y)\n\nIn-place add. x = pyiadd(x, y) is equivalent to x += y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyisub","page":"Reference","title":"PythonCall.pyisub","text":"pyisub(x, y)\n\nIn-place subtract. x = pyisub(x, y) is equivalent to x -= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyimul","page":"Reference","title":"PythonCall.pyimul","text":"pyimul(x, y)\n\nIn-place multiply. x = pyimul(x, y) is equivalent to x *= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyimatmul","page":"Reference","title":"PythonCall.pyimatmul","text":"pyimatmul(x, y)\n\nIn-place matrix multiply. x = pyimatmul(x, y) is equivalent to x @= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyipow","page":"Reference","title":"PythonCall.pyipow","text":"pyipow(x, y, z=None)\n\nIn-place power. x = pyipow(x, y) is equivalent to x **= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyifloordiv","page":"Reference","title":"PythonCall.pyifloordiv","text":"pyifloordiv(x, y)\n\nIn-place floor divide. x = pyifloordiv(x, y) is equivalent to x //= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyitruediv","page":"Reference","title":"PythonCall.pyitruediv","text":"pyitruediv(x, y)\n\nIn-place true division. x = pyitruediv(x, y) is equivalent to x /= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyimod","page":"Reference","title":"PythonCall.pyimod","text":"pyimod(x, y)\n\nIn-place subtraction. x = pyimod(x, y) is equivalent to x %= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyilshift","page":"Reference","title":"PythonCall.pyilshift","text":"pyilshift(x, y)\n\nIn-place left shift. x = pyilshift(x, y) is equivalent to x <<= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyirshift","page":"Reference","title":"PythonCall.pyirshift","text":"pyirshift(x, y)\n\nIn-place right shift. x = pyirshift(x, y) is equivalent to x >>= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyiand","page":"Reference","title":"PythonCall.pyiand","text":"pyiand(x, y)\n\nIn-place and. x = pyiand(x, y) is equivalent to x &= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyixor","page":"Reference","title":"PythonCall.pyixor","text":"pyixor(x, y)\n\nIn-place xor. x = pyixor(x, y) is equivalent to x ^= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyior","page":"Reference","title":"PythonCall.pyior","text":"pyior(x, y)\n\nIn-place or. x = pyior(x, y) is equivalent to x |= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Logic","page":"Reference","title":"Logic","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions are equivalent to the corresponding Python logical operators.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1) < Py(2), Py(1) < 2, pylt(1, 2), pylt(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"Note that the binary operators by default return Py (not Bool) since comparisons in Python do not necessarily return bool.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pytruth","page":"Reference","title":"PythonCall.pytruth","text":"pytruth(x)\n\nThe truthyness of x. Equivalent to bool(x) in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pynot","page":"Reference","title":"PythonCall.pynot","text":"pynot(x)\n\nThe falsyness of x. Equivalent to not x in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyeq","page":"Reference","title":"PythonCall.pyeq","text":"pyeq(x, y)\npyeq(Bool, x, y)\n\nEquivalent to x == y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyne","page":"Reference","title":"PythonCall.pyne","text":"pyne(x, y)\npyne(Bool, x, y)\n\nEquivalent to x != y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyle","page":"Reference","title":"PythonCall.pyle","text":"pyle(x, y)\npyle(Bool, x, y)\n\nEquivalent to x <= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pylt","page":"Reference","title":"PythonCall.pylt","text":"pylt(x, y)\npylt(Bool, x, y)\n\nEquivalent to x < y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyge","page":"Reference","title":"PythonCall.pyge","text":"pyge(x, y)\npyge(Bool, x, y)\n\nEquivalent to x >= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pygt","page":"Reference","title":"PythonCall.pygt","text":"pygt(x, y)\npygt(Bool, x, y)\n\nEquivalent to x > y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Create-classes","page":"Reference","title":"Create classes","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions can be used to create new Python classes where the functions are implemented in Julia. You can instead use @pyeval etc. to create pure-Python classes.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pytype-Tuple{Any, Any, Any}","page":"Reference","title":"PythonCall.pytype","text":"pytype(name, bases, dict)\n\nCreate a new type. Equivalent to type(name, bases, dict) in Python.\n\nIf bases is not a Python object, it is converted to one using pytuple.\n\nThe dict may either by a Python object or a Julia iterable. In the latter case, each item may either be a name => value pair or a Python object with a __name__ attribute.\n\nIn order to use a Julia Function as an instance method, it must be wrapped into a Python function with pyfunc. Similarly, see also pyclassmethod, pystaticmethod or pyproperty. In all these cases, the arguments passed to the function always have type Py. See the example below.\n\nExample\n\nFoo = pytype(\"Foo\", (), [\n    \"__module__\" => \"__main__\",\n\n    pyfunc(\n        name = \"__init__\",\n        doc = \"\"\"\n        Specify x and y to store in the Foo.\n\n        If omitted, y defaults to None.\n        \"\"\",\n        function (self, x, y = nothing)\n            self.x = x\n            self.y = y\n            return\n        end,\n    ),\n\n    pyfunc(\n        name = \"__repr__\",\n        self -> \"Foo($(self.x), $(self.y))\",\n    ),\n\n    pyclassmethod(\n        name = \"frompair\",\n        doc = \"Construct a Foo from a tuple of length two.\",\n        (cls, xy) -> cls(xy...),\n    ),\n\n    pystaticmethod(\n        name = \"hello\",\n        doc = \"Prints a friendly greeting.\",\n        (name) -> println(\"Hello, $name\"),\n    ),\n\n    \"xy\" => pyproperty(\n        doc = \"A tuple of x and y.\",\n        get = (self) -> (self.x, self.y),\n        set = function (self, xy)\n            (x, y) = xy\n            self.x = x\n            self.y = y\n            nothing\n        end,\n    ),\n])\n\n\n\n\n\n","category":"method"},{"location":"pythoncall-reference/#PythonCall.pyfunc","page":"Reference","title":"PythonCall.pyfunc","text":"pyfunc(f; [name], [qualname], [doc], [signature])\n\nWrap the callable f as an ordinary Python function.\n\nThe name, qualname, docstring or signature can optionally be set with name, qualname, doc or signature.\n\nUnlike Py(f) (or pyjl(f)), the arguments passed to f are always of type Py, i.e. they are never converted.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyclassmethod","page":"Reference","title":"PythonCall.pyclassmethod","text":"pyclassmethod(f; ...)\n\nConvert callable f to a Python class method.\n\nIf f is not a Python object (e.g. if f is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to f are always of type Py. Keyword arguments are passed to pyfunc.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pystaticmethod","page":"Reference","title":"PythonCall.pystaticmethod","text":"pystaticmethod(f; ...)\n\nConvert callable f to a Python static method.\n\nIf f is not a Python object (e.g. if f is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to f are always of type Py. Any keyword arguments are passed to pyfunc.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyproperty","page":"Reference","title":"PythonCall.pyproperty","text":"pyproperty(; get=nothing, set=nothing, del=nothing, doc=nothing)\npyproperty(get)\n\nCreate a Python property with the given getter, setter and deleter.\n\nIf get, set or del is not a Python object (e.g. if it is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to it are always of type Py.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#python-wrappers","page":"Reference","title":"Wrapper types","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"The following types wrap a Python object, giving it the semantics of a Julia object. For example PyList(x) interprets the Python sequence x as a Julia abstract vector.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"Apart from a few fundamental immutable types, conversion from Python to Julia Any will return a wrapper type such as one of these, or simply Py if no wrapper type is suitable.","category":"page"},{"location":"pythoncall-reference/#PythonCall.PyList","page":"Reference","title":"PythonCall.PyList","text":"PyList{T=Py}([x])\n\nWraps the Python list x (or anything satisfying the sequence interface) as an AbstractVector{T}.\n\nIf x is not a Python object, it is converted to one using pylist.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PySet","page":"Reference","title":"PythonCall.PySet","text":"PySet{T=Py}([x])\n\nWraps the Python set x (or anything satisfying the set interface) as an AbstractSet{T}.\n\nIf x is not a Python object, it is converted to one using pyset.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyDict","page":"Reference","title":"PythonCall.PyDict","text":"PyDict{K=Py,V=Py}([x])\n\nWraps the Python dict x (or anything satisfying the mapping interface) as an AbstractDict{K,V}.\n\nIf x is not a Python object, it is converted to one using pydict.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyIterable","page":"Reference","title":"PythonCall.PyIterable","text":"PyIterable{T=Py}(x)\n\nThis object iterates over iterable Python object x, yielding values of type T.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyArray","page":"Reference","title":"PythonCall.PyArray","text":"PyArray{T,N,M,L,R}(x; copy=true, array=true, buffer=true)\n\nWrap the Python array x as a Julia AbstractArray{T,N}.\n\nThe input x can be bytes, bytearray, array.array, numpy.ndarray or anything satisfying the buffer protocol (if buffer=true) or the numpy array interface (if array=true).\n\nIf copy=false then the resulting array is guaranteed to directly wrap the data in x. If copy=true then a copy is taken if necessary to produce an array.\n\nThe type parameters are all optional, and are:\n\nT: The element type.\nN: The number of dimensions.\nM: True if the array is mutable.\nL: True if the array supports fast linear indexing.\nR: The element type of the underlying buffer. Often equal to T.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyIO","page":"Reference","title":"PythonCall.PyIO","text":"PyIO(x; own=false, text=missing, line_buffering=false, buflen=4096)\n\nWrap the Python IO stream x as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then x must be a binary stream and arbitrary binary I/O is possible. If text=true then x must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If x is a text stream and you really need a binary stream, then often PyIO(x.buffer) will work.\n\nIf line_buffering=true then output is flushed at each line.\n\nFor efficiency, reads and writes are buffered before being sent to x. The size of the buffers is buflen. The buffers are cleared using flush.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyTable","page":"Reference","title":"PythonCall.PyTable","text":"PyTable(x)\n\nWrap x as a Tables.jl-compatible table.\n\nPyTable is an abstract type. See PyPandasDataFrame for a concrete example.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyPandasDataFrame","page":"Reference","title":"PythonCall.PyPandasDataFrame","text":"PyPandasDataFrame(x; [indexname::Union{Nothing,Symbol}], [columnnames::Function], [columntypes::Function])\n\nWraps the pandas DataFrame x as a Tables.jl-compatible table.\n\nindexname: The name of the column including the index. The default is nothing, meaning to exclude the index.\ncolumnnames: A function mapping the Python column name (a Py) to the Julia one (a Symbol). The default is x -> Symbol(x).\ncolumntypes: A function taking the column name (a Symbol) and returning either the desired element type of the column, or nothing to indicate automatic inference.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyObjectArray","page":"Reference","title":"PythonCall.PyObjectArray","text":"PyObjectArray(undef, dims...)\nPyObjectArray(array)\n\nAn array of Pys which supports the Python buffer protocol.\n\nInternally, the objects are stored as an array of pointers.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.PyException","page":"Reference","title":"PythonCall.PyException","text":"PyException(x)\n\nWraps the Python exception x as a Julia Exception.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#python-wrappers-custom","page":"Reference","title":"Custom wrappers","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"Here is a minimal example of defining a wrapper type. You may add methods, fields and a supertype to the type to specialise its behaviour. See any of the above wrapper types for examples.","category":"page"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"# The new type with a field for the Python object being wrapped.\nstruct MyType\n    py::Py\nend\n\n# Says that the object is a wrapper.\nispy(x::MyType) = true\n\n# Says how to access the underlying Python object.\nPy(x::MyType) = x.py","category":"page"},{"location":"pythoncall-reference/#@py-and-@pyconst","page":"Reference","title":"@py and @pyconst","text":"","category":"section"},{"location":"pythoncall-reference/#PythonCall.@py","page":"Reference","title":"PythonCall.@py","text":"@py expr\n\nEvaluate the given expression using Pythonic semantics.\n\nFor example:\n\nf(x, y) is translated to pycall(f, x, y)\nx + y is translated to pyadd(x, y)\nx === y is translated to pyis(x, y) (x is y in Python)\nx.foo is translated to pygetattr(x, \"foo\")\nimport x: f as g is translated to g = pyimport(\"x\" => \"f\") (from x import f as g in Python)\n\nCompound statements such as begin, if, while and for are supported.\n\nSee the online documentation for more details.\n\nwarning: Warning\nThis macro is experimental. It may be modified or removed in a future release.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#PythonCall.@pyconst","page":"Reference","title":"PythonCall.@pyconst","text":"@pyconst ex\n\nEquivalent to Py(ex) but always returns the exact same Julia object.\n\nThat is, if foo() = @pyconst ex then foo() === foo().\n\nThe expression ex is evaluated the first time the code is run.\n\nIf ex is a string literal, the string is interned.\n\nDo not use this macro at the top level of a module. Instead, use pynew() and pycopy!().\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#Multi-threading","page":"Reference","title":"Multi-threading","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions are not exported. They support multi-threading of Python and/or Julia. See also juliacall.AnyValue._jl_call_nogil.","category":"page"},{"location":"pythoncall-reference/#PythonCall.GIL.lock","page":"Reference","title":"PythonCall.GIL.lock","text":"lock(f)\n\nLock the GIL, compute f(), unlock the GIL, then return the result of f().\n\nUse this to run Python code from threads that do not currently hold the GIL, such as new threads. Since the main Julia thread holds the GIL by default, you will need to unlock the GIL before using this function.\n\nSee @lock for the macro form.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.GIL.@lock","page":"Reference","title":"PythonCall.GIL.@lock","text":"@lock expr\n\nLock the GIL, compute expr, unlock the GIL, then return the result of expr.\n\nUse this to run Python code from threads that do not currently hold the GIL, such as new threads. Since the main Julia thread holds the GIL by default, you will need to @unlock the GIL before using this function.\n\nThe macro equivalent of lock.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#PythonCall.GIL.unlock","page":"Reference","title":"PythonCall.GIL.unlock","text":"unlock(f)\n\nUnlock the GIL, compute f(), re-lock the GIL, then return the result of f().\n\nUse this to run non-Python code with the GIL unlocked, so allowing another thread to run Python code. That other thread can be a Julia thread, which must lock the GIL using lock.\n\nSee @unlock for the macro form.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.GIL.@unlock","page":"Reference","title":"PythonCall.GIL.@unlock","text":"@unlock expr\n\nUnlock the GIL, compute expr, re-lock the GIL, then return the result of expr.\n\nUse this to run non-Python code with the GIL unlocked, so allowing another thread to run Python code. That other thread can be a Julia thread, which must lock the GIL using @lock.\n\nThe macro equivalent of unlock.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall-reference/#PythonCall.GC.gc","page":"Reference","title":"PythonCall.GC.gc","text":"PythonCall.GC.gc()\n\nFree any Python objects waiting to be freed.\n\nThese are objects that were finalized from a thread that was not holding the Python GIL at the time.\n\nLike most PythonCall functions, this must only be called from the main thread (i.e. the thread currently holding the Python GIL.)\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#The-Python-interpreter","page":"Reference","title":"The Python interpreter","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"These functions are not exported. They give information about which Python interpreter is being used.","category":"page"},{"location":"pythoncall-reference/#PythonCall.python_version","page":"Reference","title":"PythonCall.python_version","text":"python_version()\n\nThe version of Python, or missing if not known.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.python_executable_path","page":"Reference","title":"PythonCall.python_executable_path","text":"python_executable_path()\n\nPath to the Python interpreter, or missing if not known.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.python_library_path","page":"Reference","title":"PythonCall.python_library_path","text":"python_library_path()\n\nPath to libpython, or missing if not known.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.python_library_handle","page":"Reference","title":"PythonCall.python_library_handle","text":"python_library_handle()\n\nHandle to the open libpython, or C_NULL if not known.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#Low-level-API","page":"Reference","title":"Low-level API","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"The functions here are not exported. They are mostly unsafe in the sense that you can crash Julia by using them incorrectly.","category":"page"},{"location":"pythoncall-reference/#PythonCall.pynew","page":"Reference","title":"PythonCall.pynew","text":"pynew([ptr])\n\nA new Py representing the Python object at ptr (NULL by default).\n\nIf ptr is given and non-NULL, this function steals a reference to the Python object it points at, i.e. the new Py object owns a reference.\n\nNote that NULL Python objects are not safe in the sense that most API functions will probably crash your Julia session if you pass a NULL argument.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pyisnull","page":"Reference","title":"PythonCall.pyisnull","text":"pyisnull(x)\n\nTrue if the Python object x is NULL.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pycopy!","page":"Reference","title":"PythonCall.pycopy!","text":"pycopy!(dst::Py, src)\n\nCopy the Python object src into dst, so that they both represent the same object.\n\nThis function exists to support module-level constant Python objects. It is illegal to call most PythonCall API functions at the top level of a module (i.e. before __init__() has run) so you cannot do const x = pything() at the top level. Instead do const x = pynew() at the top level then pycopy!(x, pything()) inside __init__().\n\nAssumes dst is NULL, otherwise a memory leak will occur.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.getptr","page":"Reference","title":"PythonCall.getptr","text":"getptr(x)\n\nGet the underlying pointer from the Python object x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.pydel!","page":"Reference","title":"PythonCall.pydel!","text":"pydel!(x::Py)\n\nDelete the Python object x.\n\nDANGER! Use this function ONLY IF the Julia object x could have been garbage-collected anyway, i.e. was about to become unreachable. This means you MUST KNOW that no other part of the program has the Julia object x.\n\nThis decrements the reference count, sets the pointer to NULL and appends x to a cache of unused objects (PYNULL_CACHE).\n\nThis is an optimization to avoid excessive allocation and deallocation in Julia, which can be a significant source of slow-down in code which uses a lot of Python objects. It allows pynew() to pop an item from PYNULL_CACHE instead of allocating one, and avoids calling the relatively slow finalizer on x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#PythonCall.unsafe_pynext","page":"Reference","title":"PythonCall.unsafe_pynext","text":"unsafe_pynext(x)\n\nReturn the next item in the iterator x. When there are no more items, return NULL.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall-reference/#NumpyDates","page":"Reference","title":"NumpyDates","text":"","category":"section"},{"location":"pythoncall-reference/","page":"Reference","title":"Reference","text":"The submodule PythonCall.NumpyDates provides types corresponding to Numpy's datetime64 and timedelta64 types. Enables conversion of these Numpy types (either as scalars or in arrays) to native Julia types.","category":"page"},{"location":"pythoncall-reference/#PythonCall.NumpyDates","page":"Reference","title":"PythonCall.NumpyDates","text":"module NumpyDates\n\nProvides datetimes and timedeltas compatible with Numpy.\n\nSee: DateTime64, InlineDateTime64, TimeDelta64 and InlineTimeDelta64.\n\nThese can generally be converted to/from their respective types in the Dates stdlib.\n\n\n\n\n\n","category":"module"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.AbstractDateTime64","page":"Reference","title":"PythonCall.NumpyDates.AbstractDateTime64","text":"abstract type AbstractDateTime64 <: Dates.TimeType\n\nSupertype for DateTime64 and InlineDateTime64.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.InlineDateTime64","page":"Reference","title":"PythonCall.NumpyDates.InlineDateTime64","text":"InlineDateTime64{unit}(value)\nInlineDateTime64{unit}(value, format)\nInlineDateTime64(value, [unit])\nInlineDateTime64(value, format, [unit])\n\nConstruct an InlineDateTime64 with the given value and unit.\n\nThe unit is part of the type, so an instance just consists of one Int64 for the value.\n\nThe value can be:\n\nAn Integer, in which case the unit is required.\nA Dates.Date or Dates.DateTime.\n\"NaT\" or \"NaN\" to make a not-a-time value.\nAn AbstractString, which is parsed the same as Dates.DateTime, with an optional format string.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.DateTime64","page":"Reference","title":"PythonCall.NumpyDates.DateTime64","text":"DateTime64(value, [unit])\nDateTime64(value, format, [unit])\n\nConstruct an DateTime64 with the given value and unit.\n\nThe unit is stored as a run-time value. If the units in your code are known, using InlineDateTime64{unit} may be preferable. The memory layout is the same as for a numpy.datetime64.\n\nThe value can be:\n\nAn Integer, in which case the unit is required.\nA Dates.Date or Dates.DateTime.\n\"NaT\" or \"NaN\" to make a not-a-time value.\nAn AbstractString, which is parsed the same as Dates.DateTime, with an optional format string.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.AbstractTimeDelta64","page":"Reference","title":"PythonCall.NumpyDates.AbstractTimeDelta64","text":"abstract type AbstractTimeDelta64 <: Dates.Period\n\nSupertype for TimeDelta64 and InlineTimeDelta64.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.InlineTimeDelta64","page":"Reference","title":"PythonCall.NumpyDates.InlineTimeDelta64","text":"InlineTimeDelta64{unit}(value)\nInlineTimeDelta64(value, [unit])\n\nConstruct an InlineTimeDelta64 with the given value and unit.\n\nThe unit is part of the type, so an instance just consists of one Int64 for the value.\n\nThe value can be:\n\nAn Integer, in which case the unit is required.\n\"NaT\" or \"NaN\" to make a not-a-time value.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.TimeDelta64","page":"Reference","title":"PythonCall.NumpyDates.TimeDelta64","text":"TimeDelta64(value, [unit])\n\nConstruct a TimeDelta64 with the given value and unit.\n\nThe unit is stored as a run-time value. If the units in your code are known, using InlineTimeDelta64{unit} may be preferable. The memory layout is the same as for a numpy.timedelta64.\n\nThe value can be:\n\nAn Integer, in which case the unit is required.\n\"NaT\" or \"NaN\" to make a not-a-time value.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall-reference/#PythonCall.NumpyDates.Unit","page":"Reference","title":"PythonCall.NumpyDates.Unit","text":"@enum Unit\n\nThe possible time units for datetimes and timedeltas in this module.\n\nValues are: YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, PICOSECONDS, FEMTOSECONDS, ATTOSECONDS.\n\nFor compatibility with numpy, the types in this module also accept scaled units as a Tuple{Unit,Int}. For example (MINUTES, 15) for units of 15 minutes. This feature is rarely used.\n\n\n\n\n\n","category":"type"},{"location":"#PythonCall-and-JuliaCall","page":"Home","title":"PythonCall & JuliaCall","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python® and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia counterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia Julia 1.9 upwards and Python 3.9 upwards.","category":"page"},{"location":"conversion-to-julia/#py2jl","page":"Python to Julia","title":"Conversion to Julia","text":"","category":"section"},{"location":"conversion-to-julia/#py2jl-conversion","page":"Python to Julia","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"The following table specifies the conversion rules used whenever converting a Python object to a Julia object. If the initial Python type matches the \"From\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example.","category":"page"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"From Python, the arguments to a Julia function will be converted according to these rules with T=Any.","category":"page"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"From To\nTop priority (wrapped values). \njuliacall.AnyValue Any\nVery high priority (arrays). \nObjects satisfying the buffer or array interface (inc. bytes, bytearray, array.array, numpy.ndarray) PyArray\nHigh priority (canonical conversions). \nNone Nothing\nbool Bool\nnumbers.Integral (inc. int) Integer (prefers Int, or BigInt on overflow)\nfloat Float64\ncomplex Complex{Float64}\nrange StepRange\nstr String\ntuple Tuple\ncollections.abc.Mapping (inc. dict) PyDict\ncollections.abc.Sequence (inc. list) PyList\ncollections.abc.Set (inc. set, frozenset) PySet\nio.IOBase (includes open files) PyIO\nBaseException PyException\ndatetime.date/datetime.time/datetime.datetime Date/Time/DateTime\ndatetime.timedelta Microsecond (or Millisecond or Second on overflow)\nnumpy.intXX/numpy.uintXX/numpy.floatXX IntXX/UIntXX/FloatXX\nnumpy.datetime64 NumpyDates.DateTime64\nnumpy.timedelta64 NumpyDates.TimeDelta64\nStandard priority (other reasonable conversions). \nNone Missing\nbytes Vector{UInt8}, Vector{Int8}, String\nstr String, Symbol, Char, Vector{UInt8}, Vector{Int8}\nrange UnitRange\ncollections.abc.Mapping Dict\ncollections.abc.Iterable Vector, Set, Tuple, NamedTuple, Pair\ndatetime.timedelta Dates.CompoundPeriod\nnumbers.Integral Integer, Rational, Real, Number\nnumbers.Real AbstractFloat, Number, Missing/Nothing (if NaN)\nnumbers.Complex Complex, Number\nctypes.c_int and other integers Integer, Rational, Real, Number\nctypes.c_float/ctypes.c_double Cfloat/Cdouble, AbstractFloat, Real, Number\nctypes.c_voidp Ptr{Cvoid}, Ptr\nctypes.c_char_p Cstring, Ptr{Cchar}, Ptr\nctypes.c_wchar_p Cwstring, Ptr{Cwchar}, Ptr\nnumpy.bool_/numpy.intXX/numpy.uintXX/numpy.floatXX Bool, Integer, Rational, Real, Number\nnumpy.datetime64 NumpyDates.InlineDateTime64, Dates.DateTime\nnumpy.timedelta64 NumpyDates.InlineTimeDelta64, Dates.Period\nObjects satisfying the buffer or array interface Array, AbstractArray\nLow priority (fallback to Py). \nAnything Py\nBottom priority (must be explicitly specified by excluding Py). \nObjects satisfying the buffer interface PyBuffer\nAnything PyRef","category":"page"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"See here for an explanation of the Py* wrapper types (PyList, PyIO, etc).","category":"page"},{"location":"conversion-to-julia/#py2jl-conversion-custom","page":"Python to Julia","title":"Custom rules","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"To add a custom conversion rule, you must define a function to do the conversion and call pyconvert_add_rule to register it.","category":"page"},{"location":"conversion-to-julia/","page":"Python to Julia","title":"Python to Julia","text":"You must not do this while precompiling, so these calls will normally be in the __init__ function of your module.","category":"page"},{"location":"conversion-to-julia/#PythonCall.pyconvert_add_rule","page":"Python to Julia","title":"PythonCall.pyconvert_add_rule","text":"pyconvert_add_rule(tname::String, T::Type, func::Function, priority::PyConvertPriority=PYCONVERT_PRIORITY_NORMAL)\n\nAdd a new conversion rule for pyconvert.\n\nArguments\n\ntname is a string of the form \"__module__:__qualname__\" identifying a Python type t, such as \"builtins:dict\" or \"sympy.core.symbol:Symbol\". This rule only applies to Python objects of this type.\nT is a Julia type, such that this rule only applies when the target type intersects with T.\nfunc is the function implementing the rule.\npriority determines whether to prioritise this rule above others.\n\nWhen pyconvert(R, x) is called, all rules such that typeintersect(T, R) != Union{} and pyisinstance(x, t) are considered. These rules are sorted first by priority, then by the specificity of t (e.g. bool is more specific than int is more specific than object) then by the order they were added. The rules are tried in turn until one succeeds.\n\nImplementing func\n\nfunc is called as func(S, x::Py) for some S <: T.\n\nIt must return one of:\n\npyconvert_return(ans) where ans is the result of the conversion (and must be an S).\npyconvert_unconverted() if the conversion was not possible (e.g. converting a list to Vector{Int} might fail if some of the list items are not integers).\n\nThe target type S is never a union or the empty type, i.e. it is always a data type or union-all.\n\nPriority\n\nMost rules should have priority PYCONVERT_PRIORITY_NORMAL (the default) which is for any reasonable conversion rule.\n\nUse priority PYCONVERT_PRIORITY_CANONICAL for canonical conversion rules. Immutable objects may be canonically converted to their corresponding Julia type, such as int to Integer. Mutable objects must be converted to a wrapper type, such that the original Python object can be retrieved. For example a list is canonically converted to PyList and not to a Vector. There should not be more than one canonical conversion rule for a given Python type.\n\nOther priorities are reserved for internal use.\n\n\n\n\n\n","category":"function"},{"location":"faq/#FAQ-and-Troubleshooting","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"","category":"section"},{"location":"faq/#faq-pycall","page":"FAQ & Troubleshooting","title":"Can I use PythonCall and PyCall together?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Yes, you can use both PyCall and PythonCall in the same Julia session. This is platform-dependent:","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"On most systems the Python interpreter used by PythonCall and PyCall must be the same (see below).\nOn Windows it appears to be possible for PythonCall and PyCall to use different interpreters.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"To force PythonCall to use the same Python interpreter as PyCall, set the environment variable JULIA_PYTHONCALL_EXE to \"@PyCall\". Note that this will opt out of automatic dependency management using CondaPkg.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Alternatively, to force PyCall to use the same interpreter as PythonCall, set the environment variable PYTHON to PythonCall.python_executable_path() and then Pkg.build(\"PyCall\"). You will need to do this each time you change project, because PythonCall by default uses a different Python for each project.","category":"page"},{"location":"faq/#faq-multi-threading","page":"FAQ & Troubleshooting","title":"Is PythonCall/JuliaCall thread safe?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Yes, as of v0.9.22, provided you handle the GIL correctly. See the guides for PythonCall and JuliaCall.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Before, tricks such as disabling the garbage collector were required. See the old docs.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"When starting a Julia REPL with multiple threads, there must be exactly one interactive thread, to avoid triggering a segmentation fault on tab completion (issue #586). Check this with Threads.nthreads(:interactive) or versioninfo(), set it with JULIA_NUM_THREADS=X,1, where X is the number of default threads, or use the Julia --threads CLI flag, see julia --help.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Related issues: #201, #202, #529","category":"page"},{"location":"faq/#Issues-when-Numpy-arrays-are-expected","page":"FAQ & Troubleshooting","title":"Issues when Numpy arrays are expected","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"When a Julia array is passed to Python, it is wrapped as a ArrayValue. This type satisfies the Numpy array interface and the buffer protocol, so can be used in most places where a numpy array is valid.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"However, some Python packages have functions which assume the input is an actual Numpy array. You may see errors such as:","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"AttributeError: Julia: type Array has no field dtype","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"To fix this you can convert the array x to a Numpy array as follows","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Py(x).to_numpy()","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"If the array is being mutated, you will need to pass the argument copy=false.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Related issues: #280","category":"page"},{"location":"faq/#Heap-corruption-when-using-PyTorch","page":"FAQ & Troubleshooting","title":"Heap corruption when using PyTorch","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"On some systems, you may see an error like the following when using torch and juliacall:","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Python(65251,0x104cf8580) malloc: Heap corruption detected, free list is damaged at 0x600001c17280\n*** Incorrect guard value: 1903002876\nPython(65251,0x104cf8580) malloc: *** set a breakpoint in malloc_error_break to debug\n[1]    65251 abort      ipython","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"A solution is to ensure that juliacall is imported before torch.","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Related issues: #215","category":"page"},{"location":"faq/#ccall-requires-the-compiler-error-when-importing-some-Python-libraries","page":"FAQ & Troubleshooting","title":"ccall requires the compiler error when importing some Python libraries","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"On some systems, you may see an error like the following when import e.g. matplotlib before juliacall:","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"ERROR: `ccall` requires the compilerTraceback (most recent call last):\n  File \"/home/dingraha/projects/pythoncall_import_error/run.py\", line 2, in <module>\n    from foo import Foo\n  File \"/home/dingraha/projects/pythoncall_import_error/foo.py\", line 4, in <module>\n    import juliacall; jl = juliacall.newmodule(\"FooModule\")\n  File \"/home/dingraha/projects/pythoncall_import_error/venv/lib/python3.9/site-packages/juliacall/__init__.py\", line 218, in <module>\n    init()\n  File \"/home/dingraha/projects/pythoncall_import_error/venv/lib/python3.9/site-packages/juliacall/__init__.py\", line 214, in init\n    raise Exception('PythonCall.jl did not start properly')\nException: PythonCall.jl did not start properly","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"The likely problem is that the \"other\" Python library (matplotlib, whatever) is loading the system libstdc++.so, which isn't compatible with the libstdc++.so that Julia ships with. Linux distributions with older libstdc++ versions seem more likely to suffer from this issue. The solution is to either:","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"use a Linux distribution with a more recent libstdc++\nimport juliacall before the other Python library, so that Julia's libstdc++ is loaded\nuse a Python from a conda environment, which will have a newer libstdc++ that is compatible with Julia's","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Related issues: #255","category":"page"},{"location":"faq/#Can-I-use-JuliaCall-to-run-Julia-inside-applications-with-embedded-Python?","page":"FAQ & Troubleshooting","title":"Can I use JuliaCall to run Julia inside applications with embedded Python?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"Yes, it may be possible. A good example of that is having Julia running inside the Python that is running inside Blender, as presented in this Discourse post. From the point that one has JuliaCall running inside Python, if it has access to the terminal, one can even launch a Julia REPL there, and if needed connect with VSCode Julia extension to it. The full Python script to install, launch JuliaCall, and launch a Julia REPL in Blender is here.","category":"page"},{"location":"faq/#Using-PythonCall.jl-and-CondaPkg.jl-in-a-script","page":"FAQ & Troubleshooting","title":"Using PythonCall.jl and CondaPkg.jl in a script","text":"","category":"section"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"If running from a script, make sure that CondaPkg.jl is used before PythonCall.jl to ensure proper loading of Python packages in your path. E.g.,","category":"page"},{"location":"faq/","page":"FAQ & Troubleshooting","title":"FAQ & Troubleshooting","text":"using CondaPkg\n\nCondaPkg.add(\"numpy\")\n\nusing PythonCall\n\nnp = pyimport(\"numpy\")","category":"page"}]
}
