var documenterSearchIndex = {"docs":
[{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#v0.8.0-(2022-03-17)","page":"Release Notes","title":"v0.8.0 (2022-03-17)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: Removes pymethod and pyclass. In the future, pyclass may become sugar for types.new_class (namely you can specify a metaclass).\nAdds pyfunc, pyclassmethod, pystaticmethod and pyproperty.\npyconvert_add_rule is now documented. Its semantics have changed, including the separator of the first argument from / to :.\nA pandas <NA> value is now converted to missing.\nA NaN in a PyPandasDataFrame is converted to missing.\nBreaking: Removes using and As from JuliaCall.\nAdds convert to JuliaCall (replacing As).\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.6.1-(2022-02-21)","page":"Release Notes","title":"v0.6.1 (2022-02-21)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Conversions from simple ctypes types, e.g. ctypes.c_float to Cfloat.\nConversions from simple numpy types, e.g. numpy.float32 to Float32.\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.6.0-(2022-02-17)","page":"Release Notes","title":"v0.6.0 (2022-02-17)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: JuliaCall now uses JuliaPkg to manage Julia dependencies.\nBug fixes.","category":"page"},{"location":"releasenotes/#v0.5.1-(2022-01-24)","page":"Release Notes","title":"v0.5.1 (2022-01-24)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bug fixes.","category":"page"},{"location":"releasenotes/#v0.5.0-(2021-12-11)","page":"Release Notes","title":"v0.5.0 (2021-12-11)","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Breaking: PythonCall now uses CondaPkg to manage Python dependencies.\nPython objects can be shared with PyCall provided it uses the same interpreter, using methods PythonCall.Py(::PyCall.PyObject) and PyCall.PyObject(::PythonCall.Py).\nAdds PythonDisplay which displays objects by printing to Python's sys.stdout. Used automatically in IPython in addition to IPythonDisplay.\nRemoves the GLOBAL mode from @pyexec. Use global in the code instead.\nBug fixes.","category":"page"},{"location":"pythoncall/#The-Julia-module-PythonCall","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"","category":"section"},{"location":"pythoncall/#Installation","page":"The Julia module PythonCall","title":"Installation","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"This package is in the general registry, so to install just type ] in the Julia REPL and run:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pkg> add PythonCall","category":"page"},{"location":"pythoncall/#Getting-started","page":"The Julia module PythonCall","title":"Getting started","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Import the module with:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"julia> using PythonCall","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Now you can interact with Python as follows:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"julia> re = pyimport(\"re\")\nPython module: <module 're' from '[...]/lib/re.py'>\n\njulia> words = re.findall(\"[a-zA-Z]+\", \"PythonCall.jl is very useful!\")\nPython list: ['PythonCall', 'jl', 'is', 'very', 'useful']\n\njulia> sentence = Py(\" \").join(words)\nPython str: 'PythonCall jl is very useful'\n\njulia> pyconvert(String, sentence)\n\"PythonCall jl is very useful\"","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"In this example:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"We used pyimport to import the re module. Equivalently we could have done @py import re (see @py).\nWe called its findall function on a pair of strings, which were automatically converted to Python strings (see Conversion to Python).\nWe called Py to explicitly convert a string to a Python string, so that we could call its join method. All Python objects are of type Py.\nWe called pyconvert to convert the Python string sentence to a Julia string (see Conversion to Julia).","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"What to read next:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"The rest of this page details the functions for interacting with Python objects, of type Py.\nIf you need to install Python packages, read here.\nWhen you call a Python function, such as re.findall(...) in the above example, its arguments are converted to Python according to this table and its return value is a Py.\nPython objects can be converted to Julia objects using pyconvert with rules according to this table.\nPython objects can also be wrapped to provide more Julian semantics. For example, a PyDict wraps a Python dict as a Julia dict, and a PyArray wraps a Python array or buffer as a Julia array. See here.","category":"page"},{"location":"pythoncall/#Py","page":"The Julia module PythonCall","title":"Py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Py\n@pyconst","category":"page"},{"location":"pythoncall/#PythonCall.Py","page":"The Julia module PythonCall","title":"PythonCall.Py","text":"Py(x)\n\nConvert x to a Python object.\n\nDo not overload this function. To define a new conversion, overload getpy.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.@pyconst","page":"The Julia module PythonCall","title":"PythonCall.@pyconst","text":"@pyconst ex\n\nEquivalent to Py(ex) but always returns the exact same Julia object.\n\nThat is, if foo() = @pyconst ex then foo() === foo().\n\nThe expression ex is evaluated the first time the code is run.\n\nIf ex is a string literal, the string is interned.\n\nDo not use this macro at the top level of a module. Instead, use pynew() and pycopy!().\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"The object pybuiltins has all the standard Python builtin objects as its properties. Hence you can access pybuiltins.None and pybuiltins.TypeError.","category":"page"},{"location":"pythoncall/#@py","page":"The Julia module PythonCall","title":"@py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"@py","category":"page"},{"location":"pythoncall/#PythonCall.@py","page":"The Julia module PythonCall","title":"PythonCall.@py","text":"@py expr\n\nEvaluate the given expression using Pythonic semantics.\n\nFor example:\n\nf(x, y) is translated to pycall(f, x, y)\nx + y is translated to pyadd(x, y)\nx === y is translated to pyis(x, y)\nx.foo is translated to pygetattr(x, \"foo\")\n\nCompound statements such as begin, if, while and for are supported.\n\nSee the online documentation for more details.\n\nwarning: Warning\nThis macro is experimental. It may be modified or removed in a future release.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Python-functions","page":"The Julia module PythonCall","title":"Python functions","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Most of the functions in this section are essentially Python builtins with a py prefix. For example pyint(x) converts x to a Python int and is equivalent to int(x) in Python when x is a Python object.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Notable exceptions are:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert to convert a Python object to a Julia object.\npyimport to import a Python module.\npyjl to directly wrap a Julia object as a Python object.\npywith to emulate the Python with statement.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If a Julia value is passed as an argument to one of these functions, it is converted to a Python value using the rules documented here.","category":"page"},{"location":"pythoncall/#Constructors","page":"The Julia module PythonCall","title":"Constructors","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions construct Python objects of builtin types from Julia values.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pybool\npycollist\npybytes\npycomplex\npydict\npyfloat\npyfrozenset\npyint\npylist\npyrange\npyrowlist\npyset\npyslice\npystr\npytuple","category":"page"},{"location":"pythoncall/#PythonCall.pybool","page":"The Julia module PythonCall","title":"PythonCall.pybool","text":"pybool(x)\n\nConvert x to a Python bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycollist","page":"The Julia module PythonCall","title":"PythonCall.pycollist","text":"pycollist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of columns.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybytes","page":"The Julia module PythonCall","title":"PythonCall.pybytes","text":"pybytes(x)\n\nConvert x to a Python bytes.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycomplex","page":"The Julia module PythonCall","title":"PythonCall.pycomplex","text":"pycomplex(x=0.0)\npycomplex(re, im)\n\nConvert x to a Python complex, or create one from given real and imaginary parts.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydict","page":"The Julia module PythonCall","title":"PythonCall.pydict","text":"pydict(x)\npydict(; x...)\n\nConvert x to a Python dict. In the second form, the keys are strings.\n\nIf x is a Python object, this is equivalent to dict(x) in Python. Otherwise x must iterate over key-value pairs.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloat","page":"The Julia module PythonCall","title":"PythonCall.pyfloat","text":"pyfloat(x=0.0)\n\nConvert x to a Python float.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfrozenset","page":"The Julia module PythonCall","title":"PythonCall.pyfrozenset","text":"pyfrozenset(x=())\n\nConvert x to a Python frozenset.\n\nIf x is a Python object, this is equivalent to frozenset(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyint","page":"The Julia module PythonCall","title":"PythonCall.pyint","text":"pyint(x=0)\n\nConvert x to a Python int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylist","page":"The Julia module PythonCall","title":"PythonCall.pylist","text":"pylist(x=())\n\nConvert x to a Python list.\n\nIf x is a Python object, this is equivalent to list(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrange","page":"The Julia module PythonCall","title":"PythonCall.pyrange","text":"pyrange([[start], [stop]], [step])\n\nConstruct a Python range. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrowlist","page":"The Julia module PythonCall","title":"PythonCall.pyrowlist","text":"pyrowlist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of rows.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyset","page":"The Julia module PythonCall","title":"PythonCall.pyset","text":"pyset(x=())\n\nConvert x to a Python set.\n\nIf x is a Python object, this is equivalent to set(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyslice","page":"The Julia module PythonCall","title":"PythonCall.pyslice","text":"pyslice([start], stop, [step])\n\nConstruct a Python slice. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pystr","page":"The Julia module PythonCall","title":"PythonCall.pystr","text":"pystr(x)\n\nConvert x to a Python str.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytuple","page":"The Julia module PythonCall","title":"PythonCall.pytuple","text":"pytuple(x=())\n\nConvert x to a Python tuple.\n\nIf x is a Python object, this is equivalent to tuple(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Builtins","page":"The Julia module PythonCall","title":"Builtins","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions mimic the Python builtin functions or keywords of the same name.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyall\npyany\npyascii\npycall\npycallable\npycompile\npycontains\npydelattr\npydelitem\npydir\npyeval\n@pyeval\npyexec\n@pyexec\npygetattr\npygetitem\npyhasattr\npyhash\npyhelp\npyimport\npyin\npyis\npyisinstance\npyissubclass\npyiter\npylen\npynext\npyprint\npyrepr\npysetattr\npysetitem\npytype(::Any)\npywith","category":"page"},{"location":"pythoncall/#PythonCall.pyall","page":"The Julia module PythonCall","title":"PythonCall.pyall","text":"pyall(x)\n\nEquivalent to all(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyany","page":"The Julia module PythonCall","title":"PythonCall.pyany","text":"pyany(x)\n\nEquivalent to any(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyascii","page":"The Julia module PythonCall","title":"PythonCall.pyascii","text":"pyascii(x)\n\nEquivalent to ascii(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycall","page":"The Julia module PythonCall","title":"PythonCall.pycall","text":"pycall(f, args...; kwargs...)\n\nCall the Python object f with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycallable","page":"The Julia module PythonCall","title":"PythonCall.pycallable","text":"pycallable(x)\n\nEquivalent to callable(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycompile","page":"The Julia module PythonCall","title":"PythonCall.pycompile","text":"pycompile(...)\n\nEquivalent to compile(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycontains","page":"The Julia module PythonCall","title":"PythonCall.pycontains","text":"pycontains(x, v)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelattr","page":"The Julia module PythonCall","title":"PythonCall.pydelattr","text":"pydelattr(x, k)\n\nEquivalent to delattr(x, k) or del x.k in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelitem","page":"The Julia module PythonCall","title":"PythonCall.pydelitem","text":"pydelitem(x, k)\n\nEquivalent to delitem(x, k) or del x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydir","page":"The Julia module PythonCall","title":"PythonCall.pydir","text":"pydir(x)\n\nEquivalent to dir(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyeval","page":"The Julia module PythonCall","title":"PythonCall.pyeval","text":"pyeval([T=Py], code, globals, locals=nothing)\n\nEvaluate the given Python code, returning the result as a T.\n\nIf globals is a Module, then a persistent dict unique to that module is used.\n\nBy default the code runs in global scope (i.e. locals===globals). To use a temporary local scope, set locals to (), or to a NamedTuple of variables to include in the scope.\n\nSee also @pyeval.\n\nExamples\n\nThe following computes 1.1+2.2 in the Main module as a Float64:\n\npyeval(Float64, \"x+y\", Main, (x=1.1, y=2.2))  # returns 3.3\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.@pyeval","page":"The Julia module PythonCall","title":"PythonCall.@pyeval","text":"@pyeval [inputs =>] code [=> T]\n\nEvaluate the given code in a new local scope and return the answer as a T.\n\nThe global scope is persistent and unique to the current module.\n\nThe code must be a literal string or command.\n\nThe inputs is a tuple of inputs of the form v=expr to be included in the local scope. Only v is required, expr defaults to v.\n\nExamples\n\nThe following computes 1.1+2.2 and returns a Float64:\n\n@pyeval (x=1.1, y=2.2) => `x+y` => Float64  # returns 3.3\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.pyexec","page":"The Julia module PythonCall","title":"PythonCall.pyexec","text":"pyexec([T=Nothing], code, globals, locals=nothing)\n\nExecute the given Python code.\n\nIf globals is a Module, then a persistent dict unique to that module is used.\n\nBy default the code runs in global scope (i.e. locals===globals). To use a temporary local scope, set locals to (), or to a NamedTuple of variables to include in the scope.\n\nIf T==Nothing then returns nothing. Otherwise T must be a concrete NamedTuple type and the corresponding items from locals are extracted and returned.\n\nSee also @pyexec.\n\nExamples\n\nThe following computes 1.1+2.2 in the Main module as a Float64:\n\npyexec(@NamedTuple{ans::Float64}, \"ans=x+y\", Main, (x=1.1, y=2.2))  # returns (ans = 3.3,)\n\nMarking variables as global saves them into the module scope, so that they are available in subsequent invocations:\n\npyexec(\"global x; x=12\", Main)\npyeval(Int, \"x\", Main)  # returns 12\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.@pyexec","page":"The Julia module PythonCall","title":"PythonCall.@pyexec","text":"@pyexec [inputs =>] code [=> outputs]\n\nExecute the given code in a new local scope.\n\nThe global scope is persistent and unique to the current module.\n\nThe code must be a literal string or command.\n\nThe inputs is a tuple of inputs of the form v=expr to be included in the local scope. Only v is required, expr defaults to v.\n\nThe outputs is a tuple of outputs of the form x::T=v, meaning that v is extracted from locals, converted to T and assigned to x. Only x is required: T defaults to Py and v defaults to x.\n\nExamples\n\nThe following computes 1.1+2.2 and assigns its value to ans as a Float64:\n\n@pyexec (x=1.1, y=2.2) => `ans=x+y` => ans::Float64  # returns 3.3\n\nMarking variables as global saves them into the module scope, so that they are available in subsequent invocations:\n\n@pyexec `global x; x=12`\n@pyeval `x` => Int  # returns 12\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.pygetattr","page":"The Julia module PythonCall","title":"PythonCall.pygetattr","text":"pygetattr(x, k, [d])\n\nEquivalent to getattr(x, k) or x.k in Python.\n\nIf d is specified, it is returned if the attribute does not exist.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetitem","page":"The Julia module PythonCall","title":"PythonCall.pygetitem","text":"pygetitem(x, k)\n\nEquivalent to getitem(x, k) or x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhasattr","page":"The Julia module PythonCall","title":"PythonCall.pyhasattr","text":"pyhasattr(x, k)\n\nEquivalent to hasattr(x, k) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhash","page":"The Julia module PythonCall","title":"PythonCall.pyhash","text":"pyhash(x)\n\nEquivalent to hash(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhelp","page":"The Julia module PythonCall","title":"PythonCall.pyhelp","text":"pyhelp([x])\n\nEquivalent to help(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimport","page":"The Julia module PythonCall","title":"PythonCall.pyimport","text":"pyimport(m)\npyimport(m => k)\npyimport(m => (k1, k2, ...))\npyimport(m1, m2, ...)\n\nImport a module m, or an attribute k, or a tuple of attributes.\n\nIf several arguments are given, return the results of importing each one in a tuple.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyin","page":"The Julia module PythonCall","title":"PythonCall.pyin","text":"pyin(v, x)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyis","page":"The Julia module PythonCall","title":"PythonCall.pyis","text":"pyis(x, y)\n\nTrue if x and y are the same Python object. Equivalent to x is y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisinstance","page":"The Julia module PythonCall","title":"PythonCall.pyisinstance","text":"pyisinstance(x, t)\n\nTest if x is of type t. Equivalent to isinstance(x, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyissubclass","page":"The Julia module PythonCall","title":"PythonCall.pyissubclass","text":"pyissubclass(s, t)\n\nTest if s is a subclass of t. Equivalent to issubclass(s, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiter","page":"The Julia module PythonCall","title":"PythonCall.pyiter","text":"pyiter(x)\n\nEquivalent to iter(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylen","page":"The Julia module PythonCall","title":"PythonCall.pylen","text":"pylen(x)\n\nThe length of x. Equivalent to len(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pynext","page":"The Julia module PythonCall","title":"PythonCall.pynext","text":"pynext(x)\n\nEquivalent to next(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyprint","page":"The Julia module PythonCall","title":"PythonCall.pyprint","text":"pyprint(...)\n\nEquivalent to print(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrepr","page":"The Julia module PythonCall","title":"PythonCall.pyrepr","text":"pyrepr(x)\n\nEquivalent to repr(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetattr","page":"The Julia module PythonCall","title":"PythonCall.pysetattr","text":"pysetattr(x, k, v)\n\nEquivalent to setattr(x, k, v) or x.k = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetitem","page":"The Julia module PythonCall","title":"PythonCall.pysetitem","text":"pysetitem(x, k, v)\n\nEquivalent to setitem(x, k, v) or x[k] = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytype-Tuple{Any}","page":"The Julia module PythonCall","title":"PythonCall.pytype","text":"pytype(x)\n\nThe Python type of x.\n\n\n\n\n\n","category":"method"},{"location":"pythoncall/#PythonCall.pywith","page":"The Julia module PythonCall","title":"PythonCall.pywith","text":"pywith(f, o, d=nothing)\n\nEquivalent to with o as x: f(x) in Python, where x is a Py.\n\nOn success, the value of f(x) is returned.\n\nIf an exception occurs but is suppressed then d is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Conversion-to-Julia","page":"The Julia module PythonCall","title":"Conversion to Julia","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions convert Python values to Julia values, using the rules documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert\n@pyconvert","category":"page"},{"location":"pythoncall/#PythonCall.pyconvert","page":"The Julia module PythonCall","title":"PythonCall.pyconvert","text":"pyconvert(T, x, [d])\n\nConvert the Python object x to a T.\n\nIf d is specified, it is returned on failure instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.@pyconvert","page":"The Julia module PythonCall","title":"PythonCall.@pyconvert","text":"@pyconvert(T, x, [onfail])\n\nConvert the Python object x to a T.\n\nOn failure, evaluates to onfail, which defaults to return pyconvert_unconverted() (mainly useful for writing conversion rules).\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Wrap-Julia-values","page":"The Julia module PythonCall","title":"Wrap Julia values","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions explicitly wrap Julia values into Python objects, documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"As documented here, Julia values are wrapped like this automatically on conversion to Python, unless the value is immutable and has a corresponding Python type.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyjl\npyjlraw\npyisjl\npyjlvalue\npybinaryio\npytextio","category":"page"},{"location":"pythoncall/#PythonCall.pyjl","page":"The Julia module PythonCall","title":"PythonCall.pyjl","text":"pyjl([t=pyjltype(x)], x)\n\nCreate a Python object wrapping the Julia object x.\n\nIf x is mutable, then mutating the returned object also mutates x, and vice versa.\n\nIts Python type is normally inferred from the type of x, but can be specified with t.\n\nFor example if x is an AbstractVector then the object will have type juliacall.VectorValue. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.\n\nTo define a custom conversion for your type T, overload pyjltype(::T).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlraw","page":"The Julia module PythonCall","title":"PythonCall.pyjlraw","text":"pyjlraw(v)\n\nCreate a Python object wrapping the Julia object x.\n\nIt has type juliacall.RawValue. This has a much more rigid \"Julian\" interface than pyjl(v). For example, accessing attributes or calling this object will always return a RawValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisjl","page":"The Julia module PythonCall","title":"PythonCall.pyisjl","text":"pyisjl(x)\n\nTest whether x is a wrapped Julia value, namely an instance of juliacall.ValueBase.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlvalue","page":"The Julia module PythonCall","title":"PythonCall.pyjlvalue","text":"pyjlvalue(x)\n\nExtract the value from the wrapped Julia value x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybinaryio","page":"The Julia module PythonCall","title":"PythonCall.pybinaryio","text":"pybinaryio(io::IO)\n\nWrap io as a Python binary IO object.\n\nThis is the default behaviour of Py(io).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytextio","page":"The Julia module PythonCall","title":"PythonCall.pytextio","text":"pytextio(io::IO)\n\nWrap io as a Python text IO object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Arithmetic","page":"The Julia module PythonCall","title":"Arithmetic","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions are equivalent to the corresponding Python arithmetic operators.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1)+Py(2), Py(1)+2, pyadd(1, 2), pyadd(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyneg\npypos\npyabs\npyinv\npyindex\npyadd\npysub\npymul\npymatmul\npypow\npyfloordiv\npytruediv\npymod\npydivmod\npylshift\npyrshift\npyand\npyxor\npyor\npyiadd\npyisub\npyimul\npyimatmul\npyipow\npyifloordiv\npyitruediv\npyimod\npyilshift\npyirshift\npyiand\npyixor\npyior","category":"page"},{"location":"pythoncall/#PythonCall.pyneg","page":"The Julia module PythonCall","title":"PythonCall.pyneg","text":"pyneg(x)\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypos","page":"The Julia module PythonCall","title":"PythonCall.pypos","text":"pypos(x)\n\nEquivalent to +x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyabs","page":"The Julia module PythonCall","title":"PythonCall.pyabs","text":"pyabs(x)\n\nEquivalent to abs(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyinv","page":"The Julia module PythonCall","title":"PythonCall.pyinv","text":"pyinv(x)\n\nEquivalent to ~x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyindex","page":"The Julia module PythonCall","title":"PythonCall.pyindex","text":"pyindex(x)\n\nConvert x losslessly to an int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyadd","page":"The Julia module PythonCall","title":"PythonCall.pyadd","text":"pyadd(x, y)\n\nEquivalent to x + y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysub","page":"The Julia module PythonCall","title":"PythonCall.pysub","text":"pysub(x, y)\n\nEquivalent to x - y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymul","page":"The Julia module PythonCall","title":"PythonCall.pymul","text":"pymul(x, y)\n\nEquivalent to x * y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymatmul","page":"The Julia module PythonCall","title":"PythonCall.pymatmul","text":"pymatmul(x, y)\n\nEquivalent to x @ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypow","page":"The Julia module PythonCall","title":"PythonCall.pypow","text":"pypow(x, y, z=None)\n\nEquivalent to x ** y or pow(x, y, z) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyfloordiv","text":"pyfloordiv(x, y)\n\nEquivalent to x // y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruediv","page":"The Julia module PythonCall","title":"PythonCall.pytruediv","text":"pytruediv(x, y)\n\nEquivalent to x / y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymod","page":"The Julia module PythonCall","title":"PythonCall.pymod","text":"pymod(x, y)\n\nEquivalent to x % y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydivmod","page":"The Julia module PythonCall","title":"PythonCall.pydivmod","text":"pydivmod(x, y)\n\nEquivalent to divmod(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylshift","page":"The Julia module PythonCall","title":"PythonCall.pylshift","text":"pylshift(x, y)\n\nEquivalent to x << y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrshift","page":"The Julia module PythonCall","title":"PythonCall.pyrshift","text":"pyrshift(x, y)\n\nEquivalent to x >> y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyand","page":"The Julia module PythonCall","title":"PythonCall.pyand","text":"pyand(x, y)\n\nEquivalent to x & y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyxor","page":"The Julia module PythonCall","title":"PythonCall.pyxor","text":"pyxor(x, y)\n\nEquivalent to x ^ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyor","page":"The Julia module PythonCall","title":"PythonCall.pyor","text":"pyor(x, y)\n\nEquivalent to x | y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiadd","page":"The Julia module PythonCall","title":"PythonCall.pyiadd","text":"pyiadd(x, y)\n\nIn-place add. x = pyiadd(x, y) is equivalent to x += y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisub","page":"The Julia module PythonCall","title":"PythonCall.pyisub","text":"pyisub(x, y)\n\nIn-place subtract. x = pyisub(x, y) is equivalent to x -= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimul","page":"The Julia module PythonCall","title":"PythonCall.pyimul","text":"pyimul(x, y)\n\nIn-place multiply. x = pyimul(x, y) is equivalent to x *= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimatmul","page":"The Julia module PythonCall","title":"PythonCall.pyimatmul","text":"pyimatmul(x, y)\n\nIn-place matrix multiply. x = pyimatmul(x, y) is equivalent to x @= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyipow","page":"The Julia module PythonCall","title":"PythonCall.pyipow","text":"pyipow(x, y, z=None)\n\nIn-place power. x = pyipow(x, y) is equivalent to x **= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyifloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyifloordiv","text":"pyifloordiv(x, y)\n\nIn-place floor divide. x = pyifloordiv(x, y) is equivalent to x //= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyitruediv","page":"The Julia module PythonCall","title":"PythonCall.pyitruediv","text":"pyitruediv(x, y)\n\nIn-place true division. x = pyitruediv(x, y) is equivalent to x /= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimod","page":"The Julia module PythonCall","title":"PythonCall.pyimod","text":"pyimod(x, y)\n\nIn-place subtraction. x = pyimod(x, y) is equivalent to x %= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyilshift","page":"The Julia module PythonCall","title":"PythonCall.pyilshift","text":"pyilshift(x, y)\n\nIn-place left shift. x = pyilshift(x, y) is equivalent to x <<= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyirshift","page":"The Julia module PythonCall","title":"PythonCall.pyirshift","text":"pyirshift(x, y)\n\nIn-place right shift. x = pyirshift(x, y) is equivalent to x >>= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiand","page":"The Julia module PythonCall","title":"PythonCall.pyiand","text":"pyiand(x, y)\n\nIn-place and. x = pyiand(x, y) is equivalent to x &= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyixor","page":"The Julia module PythonCall","title":"PythonCall.pyixor","text":"pyixor(x, y)\n\nIn-place xor. x = pyixor(x, y) is equivalent to x ^= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyior","page":"The Julia module PythonCall","title":"PythonCall.pyior","text":"pyior(x, y)\n\nIn-place or. x = pyior(x, y) is equivalent to x |= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Logic","page":"The Julia module PythonCall","title":"Logic","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions are equivalent to the corresponding Python logical operators.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1) < Py(2), Py(1) < 2, pylt(1, 2), pylt(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the binary operators by default return Py (not Bool) since comparisons in Python do not necessarily return bool.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pytruth\npynot\npyeq\npyne\npyle\npylt\npyge\npygt","category":"page"},{"location":"pythoncall/#PythonCall.pytruth","page":"The Julia module PythonCall","title":"PythonCall.pytruth","text":"pytruth(x)\n\nThe truthyness of x. Equivalent to bool(x) in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pynot","page":"The Julia module PythonCall","title":"PythonCall.pynot","text":"pynot(x)\n\nThe falsyness of x. Equivalent to not x in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyeq","page":"The Julia module PythonCall","title":"PythonCall.pyeq","text":"pyeq(x, y)\npyeq(Bool, x, y)\n\nEquivalent to x == y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyne","page":"The Julia module PythonCall","title":"PythonCall.pyne","text":"pyne(x, y)\npyne(Bool, x, y)\n\nEquivalent to x != y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyle","page":"The Julia module PythonCall","title":"PythonCall.pyle","text":"pyle(x, y)\npyle(Bool, x, y)\n\nEquivalent to x <= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylt","page":"The Julia module PythonCall","title":"PythonCall.pylt","text":"pylt(x, y)\npylt(Bool, x, y)\n\nEquivalent to x < y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyge","page":"The Julia module PythonCall","title":"PythonCall.pyge","text":"pyge(x, y)\npyge(Bool, x, y)\n\nEquivalent to x >= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygt","page":"The Julia module PythonCall","title":"PythonCall.pygt","text":"pygt(x, y)\npygt(Bool, x, y)\n\nEquivalent to x > y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Create-classes","page":"The Julia module PythonCall","title":"Create classes","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions can be used to create new Python classes where the functions are implemented in Julia. You can instead use @pyeval etc. to create pure-Python classes.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pytype(::Any, ::Any, ::Any)\npyfunc\npyclassmethod\npystaticmethod\npyproperty","category":"page"},{"location":"pythoncall/#PythonCall.pytype-Tuple{Any, Any, Any}","page":"The Julia module PythonCall","title":"PythonCall.pytype","text":"pytype(name, bases, dict)\n\nCreate a new type. Equivalent to type(name, bases, dict) in Python.\n\nIf bases is not a Python object, it is converted to one using pytuple.\n\nThe dict may either by a Python object or a Julia iterable. In the latter case, each item may either be a name => value pair or a Python object with a __name__ attribute.\n\nIn order to use a Julia Function as an instance method, it must be wrapped into a Python function with pyfunc. Similarly, see also pyclassmethod, pystaticmethod or pyproperty. In all these cases, the arguments passed to the function always have type Py. See the example below.\n\nExample\n\nFoo = pytype(\"Foo\", (), [\n    \"__module__\" => \"__main__\",\n\n    pyfunc(\n        name = \"__init__\",\n        doc = \"\"\"\n        Specify x and y to store in the Foo.\n\n        If omitted, y defaults to None.\n        \"\"\",\n        function (self, x, y = nothing)\n            self.x = x\n            self.y = y\n            return\n        end,\n    ),\n\n    pyfunc(\n        name = \"__repr__\",\n        self -> \"Foo($(self.x), $(self.y))\",\n    ),\n\n    pyclassmethod(\n        name = \"frompair\",\n        doc = \"Construct a Foo from a tuple of length two.\",\n        (cls, xy) -> cls(xy...),\n    ),\n\n    pystaticmethod(\n        name = \"hello\",\n        doc = \"Prints a friendly greeting.\",\n        (name) -> println(\"Hello, $name\"),\n    ),\n\n    \"xy\" => pyproperty(\n        doc = \"A tuple of x and y.\",\n        get = (self) -> (self.x, self.y),\n        set = function (self, xy)\n            (x, y) = xy\n            self.x = x\n            self.y = y\n            nothing\n        end,\n    ),\n])\n\n\n\n\n\n","category":"method"},{"location":"pythoncall/#PythonCall.pyfunc","page":"The Julia module PythonCall","title":"PythonCall.pyfunc","text":"pyfunc(f; name=nothing, qualname=name, doc=nothing, signature=nothing)\n\nWrap the callable f as an ordinary Python function.\n\nThe name, qualname, docstring or signature can optionally be set with name, qualname, doc or signature.\n\nUnlike Py(f) (or pyjl(f)), the arguments passed to f are always of type Py, i.e. they are never converted.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyclassmethod","page":"The Julia module PythonCall","title":"PythonCall.pyclassmethod","text":"pyclassmethod(f; ...)\n\nConvert callable f to a Python class method.\n\nIf f is not a Python object (e.g. if f is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to f are always of type Py. Keyword arguments are passed to pyfunc.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pystaticmethod","page":"The Julia module PythonCall","title":"PythonCall.pystaticmethod","text":"pystaticmethod(f; ...)\n\nConvert callable f to a Python static method.\n\nIf f is not a Python object (e.g. if f is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to f are always of type Py. Any keyword arguments are passed to pyfunc.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyproperty","page":"The Julia module PythonCall","title":"PythonCall.pyproperty","text":"pyproperty(; get=nothing, set=nothing, del=nothing, doc=nothing)\npyproperty(get)\n\nCreate a Python property with the given getter, setter and deleter.\n\nIf get, set or del is not a Python object (e.g. if it is a Function) then it is converted to one with pyfunc. In particular this means the arguments passed to it are always of type Py.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#python-deps","page":"The Julia module PythonCall","title":"Installing Python packages","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PythonCall uses CondaPkg.jl to manage its dependencies. Namely, CondaPkg will automatically install Python and any packages required into a Conda environment specific to your current project.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If your project requires any Python packages, add a CondaPkg.toml file to your project specifying what you need. Alternatively use CondaPkg.add() to add dependencies from the REPL.","category":"page"},{"location":"pythoncall/#Writing-packages-which-depend-on-PythonCall","page":"The Julia module PythonCall","title":"Writing packages which depend on PythonCall","text":"","category":"section"},{"location":"pythoncall/#Example","page":"The Julia module PythonCall","title":"Example","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"See https://github.com/cjdoris/Faiss.jl for an example package which wraps the Python FAISS package.","category":"page"},{"location":"pythoncall/#Precompilation","page":"The Julia module PythonCall","title":"Precompilation","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"You may not interact with Python during module precompilation. Therefore, instead of","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"module MyModule\n  using PythonCall\n  const foo = pyimport(\"foo\")\n  bar() = foo.bar() # will crash when called\nend","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"you must do","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"module MyModule\n  using PythonCall\n  const foo = PythonCall.pynew() # initially NULL\n  function __init__()\n    PythonCall.pycopy!(foo, pyimport(\"foo\"))\n  end\n  bar() = foo.bar() # now ok\nend","category":"page"},{"location":"pythoncall/#Dependencies","page":"The Julia module PythonCall","title":"Dependencies","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If your package depends on some Python packages, you must write a CondaPkg.toml file. See Installing Python packages.","category":"page"},{"location":"pythoncall/#Low-level-API","page":"The Julia module PythonCall","title":"Low-level API","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"The functions here are not exported. They are mostly unsafe in the sense that you can crash Julia by using them incorrectly.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PythonCall.pynew\nPythonCall.pyisnull\nPythonCall.pycopy!\nPythonCall.getptr\nPythonCall.pydel!\nPythonCall.unsafe_pynext","category":"page"},{"location":"pythoncall/#PythonCall.pynew","page":"The Julia module PythonCall","title":"PythonCall.pynew","text":"pynew([ptr])\n\nA new Py representing the Python object at ptr (NULL by default).\n\nIf ptr is given and non-NULL, this function steals a reference to the Python object it points at, i.e. the new Py object owns a reference.\n\nNote that NULL Python objects are not safe in the sense that most API functions will probably crash your Julia session if you pass a NULL argument.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisnull","page":"The Julia module PythonCall","title":"PythonCall.pyisnull","text":"pyisnull(x)\n\nTrue if the Python object x is NULL.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycopy!","page":"The Julia module PythonCall","title":"PythonCall.pycopy!","text":"pycopy!(dst::Py, src)\n\nCopy the Python object src into dst, so that they both represent the same object.\n\nThis function exists to support module-level constant Python objects. It is illegal to call most PythonCall API functions at the top level of a module (i.e. before __init__() has run) so you cannot do const x = pything() at the top level. Instead do const x = pynew() at the top level then pycopy!(x, pything()) inside __init__().\n\nAssumes dst is NULL, otherwise a memory leak will occur.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.getptr","page":"The Julia module PythonCall","title":"PythonCall.getptr","text":"getptr(x)\n\nGet the underlying pointer from the Python object x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydel!","page":"The Julia module PythonCall","title":"PythonCall.pydel!","text":"pydel!(x::Py)\n\nDelete the Python object x.\n\nDANGER! Use this function ONLY IF the Julia object x could have been garbage-collected anyway, i.e. was about to become unreachable. This means you MUST KNOW that no other part of the program has the Julia object x.\n\nThis decrements the reference count, sets the pointer to NULL and appends x to a cache of unused objects (PYNULL_CACHE).\n\nThis is an optimization to avoid excessive allocation and deallocation in Julia, which can be a significant source of slow-down in code which uses a lot of Python objects. It allows pynew() to pop an item from PYNULL_CACHE instead of allocating one, and avoids calling the relatively slow finalizer on x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.unsafe_pynext","page":"The Julia module PythonCall","title":"PythonCall.unsafe_pynext","text":"unsafe_pynext(x)\n\nReturn the next item in the iterator x. When there are no more items, return NULL.\n\n\n\n\n\n","category":"function"},{"location":"juliacall/#The-Python-module-JuliaCall","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"","category":"section"},{"location":"juliacall/#Installation","page":"The Python module JuliaCall","title":"Installation","text":"","category":"section"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"It's as simple as","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"pip install juliacall","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"Developers may wish to clone the repo (https://github.com/cjdoris/PythonCall.jl) directly and pip install the module in editable mode. You should add \"dev\":true, \"path\":\"../..\" to python/juliacall/juliapkg.json to ensure you use the development version of PythonCall in conjunction with JuliaCall.","category":"page"},{"location":"juliacall/#Getting-started","page":"The Python module JuliaCall","title":"Getting started","text":"","category":"section"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"For interactive or scripting use, the simplest way to get started is:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"from juliacall import Main as jl","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"This loads a single variable jl which represents the Main module in Julia, from which all of Julia's functionality is available:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"jl.println(\"Hello from Julia!\")\n# Hello from Julia!\nx = jl.rand(range(10), 3, 5)\nx._jl_display()\n# 35 Matrix{Int64}:\n#  8  1  7  0  6\n#  9  2  1  4  0\n#  1  8  5  4  0\nimport numpy\nnumpy.sum(x, axis=0)\n# array([18, 11, 13,  8,  6], dtype=int64)","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"In this example:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"We called the jl.println function to print a message.\nWe called the jl.rand function to generate an array of random integers. Note that the first argument is range(10) which is converted to 0:9 in Julia.\nWe called its special _jl_display() to show it using Julia's display mechanism.\nWe called the numpy.sum function to sum each column of x. This automatically converted x to a NumPy array. (We could have done jl.sum(x, dims=1) too.)","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"If you are writing a package which uses Julia, then to avoid polluting the global Main namespace you instead should start with:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"import juliacall; jl = juliacall.newmodule(\"SomeName\");","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"What to read next:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"The main functionality of this package is in AnyValue objects, which represent Julia objects, documented here.\nIf you need to install Julia packages, read here.\nWhen you call a Julia function, such as jl.rand(...) in the above example, its arguments are converted to Julia according to this table and its return value is converted to Python according to this table.","category":"page"},{"location":"juliacall/#julia-deps","page":"The Python module JuliaCall","title":"Managing Julia dependencies","text":"","category":"section"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"JuliaCall manages its Julia dependencies using JuliaPkg.","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"It will automatically download a suitable version of Julia if required.","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"A Julia environment is also created, activated and populated with any required packages. If you are in a virtual or Conda environment, the environment is put there. Otherwise a global environment is used at ~/.julia/environments/pyjuliapkg.","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"If your project requires any Julia packages, or a particular version of Julia itself, then create a file called juliapkg.json in your package. For example: Here is an example:","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"{\n    \"julia\": \"1.5\",\n    \"packages\": {\n        \"Example\": {\n            \"uuid\": \"7876af07-990d-54b4-ab0e-23690620f79a\",\n            \"version\": \"0.5, 0.6\"\n        }\n    }\n}","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"Alternatively you can use add, rm, etc. from JuliaPkg to edit this file.","category":"page"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"See JuliaPkg for more details.","category":"page"},{"location":"juliacall/#Utilities","page":"The Python module JuliaCall","title":"Utilities","text":"","category":"section"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"juliacall.convert - Function\n\n```python\nconvert(T, x)\n```\n\nConvert `x` to a Julia object of type `T`.\n\nYou can use this to pass an argument to a Julia function of a specific type.","category":"page"},{"location":"juliacall/#juliacall.convert","page":"The Python module JuliaCall","title":"juliacall.convert","text":"convert(T, x)\n\nConvert x to a Julia object of type T.\n\nYou can use this to pass an argument to a Julia function of a specific type.\n\n","category":"function"},{"location":"juliacall/","page":"The Python module JuliaCall","title":"The Python module JuliaCall","text":"juliacall.newmodule - Function\n\n```python\nnewmodule(name)\n```\n\nA new module with the given name.","category":"page"},{"location":"juliacall/#juliacall.newmodule","page":"The Python module JuliaCall","title":"juliacall.newmodule","text":"newmodule(name)\n\nA new module with the given name.\n\n","category":"function"},{"location":"conversion-to-python/#jl2py","page":"Conversion to Python","title":"Conversion to Python","text":"","category":"section"},{"location":"conversion-to-python/#jl2py-conversion","page":"Conversion to Python","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"The following table specifies the conversion rules used whenever converting a Julia object to a Python object.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From Julia, this occurs explicitly with Py(x) or implicitly when passing Julia objects as the argument to a Python function. To avoid this automatic conversion, the user can convert objects explicitly, such as by calling pylist or pydict.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From Python, this occurs when converting the return value of a Julia function.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From To\nAny Python object type (Py, PyList, etc.) itself\nNothing, Missing None\nBool bool\nStandard integer (IntXX, UIntXX, BigInt) int\nStandard rational (Rational{T}, T a standard integer) fractions.Fraction\nStandard float (FloatXX) float\nStandard complex (Complex{T}, T a standard float) complex\nStandard string/char (String and SubString{String}, Char) str\nTuple tuple\nStandard integer range (AbstractRange{T}, T a standard integer) range\nDate, Time, DateTime (from Dates) date, time, datetime (from datetime)\nSecond, Millisecond, Microsecond, Nanosecond (from Dates) timedelta (from datetime)\nNumber juliacall.NumberValue, juliacall.ComplexValue, etc.\nAbstractArray juliacall.ArrayValue, juliacall.VectorValue\nAbstractDict juliacall.DictValue\nAbstractSet juliacall.SetValue\nIO juliacall.BufferedIOValue\nModule juliacall.ModuleValue\nType juliacall.TypeValue\nAnything else juliacall.AnyValue","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"See below for an explanation of the juliacall.*Value types.","category":"page"},{"location":"conversion-to-python/#jl2py-conversion-custom","page":"Conversion to Python","title":"Custom rules","text":"","category":"section"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"You may define a new conversion rule for your new type T by overloading getpy(::T).","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"PythonCall.getpy\nPythonCall.ispy","category":"page"},{"location":"conversion-to-python/#PythonCall.getpy","page":"Conversion to Python","title":"PythonCall.getpy","text":"getpy(x)\n\nConvert x to a Py.\n\nOverload this function (not Py) to define a new conversion to Python.\n\nIf x is a simple wrapper around a Python object (such as PyList or PyDict) then getpy(x) should return the Python object. You should also define ispy(x) = true. This means that when x is passed back to Python, the underlying object is used directly.\n\nOptional optimization (for experts)\n\nIf ispy(x) is false and the returned Julia object ans is not referenced anywhere else, in the sense that pydel!(ans) would be safe, you may instead return NewPy(ans).\n\nThis can avoid the Julia garbage collector in performance-critical code.\n\nIf ispy(x) is true, you must return a Py.\n\n\n\n\n\n","category":"function"},{"location":"conversion-to-python/#PythonCall.ispy","page":"Conversion to Python","title":"PythonCall.ispy","text":"ispy(x)\n\nTrue if x is a Python object.\n\nThis includes Py and Python wrapper types such as PyList.\n\n\n\n\n\n","category":"function"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"Alternatively, if you define a wrapper type (a subtype of juliacall.AnyValue) then you may instead define pyjltype(::T) to be that type.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"PythonCall.pyjltype","category":"page"},{"location":"conversion-to-python/#PythonCall.pyjltype","page":"Conversion to Python","title":"PythonCall.pyjltype","text":"pyjltype(x)\n\nThe subtype of juliacall.AnyValue which the Julia object x is wrapped as by pyjl(x).\n\nOverload pyjltype(::T) to define a custom conversion for your type T.\n\n\n\n\n\n","category":"function"},{"location":"conversion-to-python/#julia-wrappers","page":"Conversion to Python","title":"Wrapper types","text":"","category":"section"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"Apart from a few fundamental immutable types, all Julia values are by default converted into Python to some AnyValue object, which wraps the original value, but giving it a Pythonic interface.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"Some types are converted to a subclass of AnyValue which provides additional Python semantics - e.g. Julia vectors are interpreted as Python sequences.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"There is also a RawValue object, which gives a stricter \"Julia-only\" interface, documented below. These types all inherit from ValueBase:","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"ValueBase\nRawValue\nAnyValue\nNumberValue\nComplexValue\nRealValue\nRationalValue\nIntegerValue\nArrayValue\nVectorValue\nDictValue\nSetValue\nIOValue\nBinaryIOValue\nTextIOValue\nModuleValue\nTypeValue","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.AnyValue - Class\n\nWraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), iteration, comparisons, `len(x)`, `a in x`, `dir(x)`.\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to [this table](@ref jl2py). This is typically a builtin Python type (for immutables) or a subtype of `AnyValue`.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, `_b` at the end of an attribute is replaced with `!` and `_bb` is replaced with `!!`.\n\n###### Members\n- `_jl_raw()`: Convert to a [`RawValue`](#juliacall.RawValue). (See also [`pyjlraw`](@ref).)\n- `_jl_display()`: Display the object using Julia's display mechanism.\n- `_jl_help()`: Display help for the object.","category":"page"},{"location":"conversion-to-python/#juliacall.AnyValue","page":"Conversion to Python","title":"juliacall.AnyValue","text":"Wraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), iteration, comparisons, len(x), a in x, dir(x).\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to this table. This is typically a builtin Python type (for immutables) or a subtype of AnyValue.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, _b at the end of an attribute is replaced with ! and _bb is replaced with !!.\n\nMembers\n\n_jl_raw(): Convert to a RawValue. (See also pyjlraw.)\n_jl_display(): Display the object using Julia's display mechanism.\n_jl_help(): Display help for the object.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.NumberValue - Class\n\nThis wraps any Julia `Number` value. It is a subclass of `numbers.Number` and behaves similar to other Python numbers.\n\nThere are also subtypes `ComplexValue`, `RealValue`, `RationalValue`, `IntegerValue` which wrap values of the corresponding Julia types, and are subclasses of the corresponding `numbers` ABC.","category":"page"},{"location":"conversion-to-python/#juliacall.NumberValue","page":"Conversion to Python","title":"juliacall.NumberValue","text":"This wraps any Julia Number value. It is a subclass of numbers.Number and behaves similar to other Python numbers.\n\nThere are also subtypes ComplexValue, RealValue, RationalValue, IntegerValue which wrap values of the corresponding Julia types, and are subclasses of the corresponding numbers ABC.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.ArrayValue - Class\n\nThis wraps any Julia `AbstractArray` value. It is a subclass of `collections.abc.Collection`.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype `VectorValue` which wraps any `AbstractVector`. It is a subclass of `collections.abc.Sequence` and behaves similar to a Python `list`.\n\nIf the array is strided and its eltype is supported (i.e. `Bool`, `IntXX`, `UIntXX`, `FloatXX`, `Complex{FloatXX}`, `Ptr{Cvoid}` or `Tuple` or `NamedTuple` of these) then it supports the buffer protocol and the numpy array interface. This means that `numpy.asarray(this)` will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy `__array__` method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, `numpy.asarray(this)` is a copy of the original array.\n\n###### Members\n- `ndim`: The number of dimensions.\n- `shape`: Tuple of lengths in each dimension.\n- `copy()`: A copy of the array.\n- `reshape(shape)`: A reshaped view of the array.","category":"page"},{"location":"conversion-to-python/#juliacall.ArrayValue","page":"Conversion to Python","title":"juliacall.ArrayValue","text":"This wraps any Julia AbstractArray value. It is a subclass of collections.abc.Collection.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype VectorValue which wraps any AbstractVector. It is a subclass of collections.abc.Sequence and behaves similar to a Python list.\n\nIf the array is strided and its eltype is supported (i.e. Bool, IntXX, UIntXX, FloatXX, Complex{FloatXX}, Ptr{Cvoid} or Tuple or NamedTuple of these) then it supports the buffer protocol and the numpy array interface. This means that numpy.asarray(this) will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy __array__ method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, numpy.asarray(this) is a copy of the original array.\n\nMembers\n\nndim: The number of dimensions.\nshape: Tuple of lengths in each dimension.\ncopy(): A copy of the array.\nreshape(shape): A reshaped view of the array.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.DictValue - Class\nThis wraps any Julia `AbstractDict` value. It is a subclass of `collections.abc.Mapping` and behaves similar to a Python `dict`.","category":"page"},{"location":"conversion-to-python/#juliacall.DictValue","page":"Conversion to Python","title":"juliacall.DictValue","text":"This wraps any Julia AbstractDict value. It is a subclass of collections.abc.Mapping and behaves similar to a Python dict.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.SetValue - Class\nThis wraps any Julia `AbstractSet` value. It is a subclass of `collections.abc.Set` and behaves similar to a Python `set`.","category":"page"},{"location":"conversion-to-python/#juliacall.SetValue","page":"Conversion to Python","title":"juliacall.SetValue","text":"This wraps any Julia AbstractSet value. It is a subclass of collections.abc.Set and behaves similar to a Python set.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.IOValue - Class\n\nThis wraps any Julia `IO` value. It is a subclass of `io.IOBase` and behaves like Python files.\n\nThere are also subtypes `BinaryIOValue` and `TextIOValue`, which are subclasses of `io.BufferedIOBase` (buffered bytes) and `io.TextIOBase` (text).","category":"page"},{"location":"conversion-to-python/#juliacall.IOValue","page":"Conversion to Python","title":"juliacall.IOValue","text":"This wraps any Julia IO value. It is a subclass of io.IOBase and behaves like Python files.\n\nThere are also subtypes BinaryIOValue and TextIOValue, which are subclasses of io.BufferedIOBase (buffered bytes) and io.TextIOBase (text).\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.ModuleValue - Class\nThis wraps any Julia `Module` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except for one additional convenience method:\n- `seval([module=self], code)`: Evaluates the given code (a string) in the given module.","category":"page"},{"location":"conversion-to-python/#juliacall.ModuleValue","page":"Conversion to Python","title":"juliacall.ModuleValue","text":"This wraps any Julia Module value.\n\nIt is the same as AnyValue except for one additional convenience method:\n\nseval([module=self], code): Evaluates the given code (a string) in the given module.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.TypeValue - Class\n\nThis wraps any Julia `Type` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\n```python\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n```","category":"page"},{"location":"conversion-to-python/#juliacall.TypeValue","page":"Conversion to Python","title":"juliacall.TypeValue","text":"This wraps any Julia Type value.\n\nIt is the same as AnyValue except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.RawValue - Class\n\nWraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), `len(x)`, `dir(x)`.\n\nThis is very similar to [`AnyValue`](#juliacall.AnyValue) except that indexing, calling, etc. will always return a `RawValue`.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\n###### Members\n- `_jl_any()`: Convert to a [`AnyValue`](#juliacall.AnyValue) (or subclass). (See also [`pyjl`](@ref).)","category":"page"},{"location":"conversion-to-python/#juliacall.RawValue","page":"Conversion to Python","title":"juliacall.RawValue","text":"Wraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), len(x), dir(x).\n\nThis is very similar to AnyValue except that indexing, calling, etc. will always return a RawValue.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\nMembers\n\n_jl_any(): Convert to a AnyValue (or subclass). (See also pyjl.)\n\n","category":"class"},{"location":"compat/#Compatibility-Tools","page":"Compatibility Tools","title":"Compatibility Tools","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some packages require a little extra help to work nicely with PythonCall.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some of these are \"fixes\" that are silently applied for you, and some are just extra functions to bridge a gap. We aim to keep these as minimal as possible.","category":"page"},{"location":"compat/#Stdlib","page":"Compatibility Tools","title":"Stdlib","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Whenever a Python exception is displayed by Julia, sys.last_traceback and friends are set. This allows the post-mortem debugger pdb.pm() to work. Disable by setting PythonCall.CONFIG.auto_sys_last_traceback = false.","category":"page"},{"location":"compat/#Tabular-data-and-Pandas","page":"Compatibility Tools","title":"Tabular data & Pandas","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"A pandas.DataFrame can be wrapped in Julia as a PyPandasDataFrame, providing a Tables.jl-compatible interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Furthermore, any Python object which can be converted to a PyTable (e.g. pandas.DataFrame can be converted to PyPandasDataFrame) satisfies the Tables.jl interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"In the other direction, the following functions can be used to convert any Tables.jl-compatible table to a Python table.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"pytable","category":"page"},{"location":"compat/#PythonCall.pytable","page":"Compatibility Tools","title":"PythonCall.pytable","text":"pytable(src, format=:pandas; ...)\n\nConstruct a Python table from the Tables.jl-compatible table src.\n\nThe format controls the type of the resulting table, and is one of:\n\n:pandas: A pandas.DataFrame. Keyword arguments are passed to the DataFrame constructor.\n:columns: A dict mapping column names to columns.\n:rows: A list of rows, which are namedtuples.\n:rowdicts: A list of rows, which are dicts.\n\n\n\n\n\n","category":"function"},{"location":"compat/#MatPlotLib-/-PyPlot-/-Seaborn","page":"Compatibility Tools","title":"MatPlotLib / PyPlot / Seaborn","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"MatPlotLib figures can be shown with Julia's display mechanism, like display(fig) or display(mime, fig).","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"This means that if you return a figure from a Jupyter or Pluto notebook cell, it will be shown. You can call display(plt.gcf()) to display the current figure.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"We also provide a simple MatPlotLib backend: mpl.use(\"module://juliacall.matplotlib\"). Now you can call plt.show() to display the figure with Julia's display mechanism. You can specify the format like plt.show(format=\"png\").","category":"page"},{"location":"compat/#GUIs-(including-MatPlotLib)","page":"Compatibility Tools","title":"GUIs (including MatPlotLib)","text":"","category":"section"},{"location":"compat/#Event-loops","page":"Compatibility Tools","title":"Event loops","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If for example you wish to use PyPlot in interactive mode (matplotlib.pyplot.ion()) then activating the correct event loop will allow it to work.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.event_loop_on\nPythonCall.event_loop_off","category":"page"},{"location":"compat/#PythonCall.event_loop_on","page":"Compatibility Tools","title":"PythonCall.event_loop_on","text":"event_loop_on(g::Symbol; interval=0.04, fix=false)\n\nActivate an event loop for the GUI framework g, so that the framework can run in the background of a Julia session.\n\nThe event loop runs every interval seconds. If fix is true and g is a Qt framework, then fix_qt_plugin_path is called.\n\nSupported values of g (and the Python module they relate to) are: :pyqt4 (PyQt4), :pyqt5 (PyQt5), :pyside (PySide), :pyside2 (PySide2), :gtk (gtk), :gtk3 (gi), :wx (wx), :tkinter (tkinter).\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.event_loop_off","page":"Compatibility Tools","title":"PythonCall.event_loop_off","text":"event_loop_off(g::Symbol)\n\nTerminate the event loop g if it is running.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Qt-path-fix","page":"Compatibility Tools","title":"Qt path fix","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.fix_qt_plugin_path","category":"page"},{"location":"compat/#PythonCall.fix_qt_plugin_path","page":"Compatibility Tools","title":"PythonCall.fix_qt_plugin_path","text":"fix_qt_plugin_path()\n\nTry to set the QT_PLUGIN_PATH environment variable in Python, if not already set.\n\nThis fixes the problem that Qt does not know where to find its qt.conf file, because it always looks relative to sys.executable, which can be the Julia executable not the Python one when using this package.\n\nIf CONFIG.auto_fix_qt_plugin_path is true, then this is run automatically before PyQt4, PyQt5, PySide or PySide2 are imported.\n\n\n\n\n\n","category":"function"},{"location":"compat/#IPython","page":"Compatibility Tools","title":"IPython","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If Python is running an IPython kernel, then:","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Currently disabled: Julia's Base.stdout is set to Python's sys.stdout.\nA PythonDisplay and IPythonDisplay are pushed onto Julia's display stack, so that display(x) goes to IPython if possible.","category":"page"},{"location":"#PythonCall-and-JuliaCall","page":"Home","title":"PythonCall & JuliaCall","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"conversion-to-julia/#py2jl","page":"Conversion to Julia","title":"Conversion to Julia","text":"","category":"section"},{"location":"conversion-to-julia/#py2jl-conversion","page":"Conversion to Julia","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"The following table specifies the conversion rules used whenever converting a Python object to a Julia object. If the initial Python type matches the \"From\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From Python, the arguments to a Julia function will be converted according to these rules with T=Any.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From To\nTop priority (wrapped values). \njuliacall.AnyValue Any\nVery high priority (arrays). \nObjects satisfying the buffer or array interface (inc. bytes, bytearray, array.array, numpy.ndarray) PyArray\nHigh priority (canonical conversions). \nNone Nothing\nbool Bool\nnumbers.Integral (inc. int) Integer (prefers Int, or BigInt on overflow)\nfloat Float64\ncomplex Complex{Float64}\nrange StepRange\nstr String\ntuple Tuple\ncollections.abc.Mapping (inc. dict) PyDict\ncollections.abc.Sequence (inc. list) PyList\ncollections.abc.Set (inc. set, frozenset) PySet\nio.IOBase (includes open files) PyIO\nBaseException PyException\ndatetime.date/datetime.time/datetime.datetime Date/Time/DateTime\ndatetime.timedelta Microsecond (or Millisecond or Second on overflow)\nnumpy.intXX/numpy.uintXX/numpy.floatXX IntXX/UIntXX/FloatXX\nStandard priority (other reasonable conversions). \nNone Missing\nbytes Vector{UInt8}, Vector{Int8}, String\nstr String, Symbol, Char, Vector{UInt8}, Vector{Int8}\nrange UnitRange\ncollections.abc.Mapping Dict\ncollections.abc.Iterable Vector, Set, Tuple, NamedTuple, Pair\ndatetime.timedelta Dates.CompoundPeriod\nnumbers.Integral Integer, Rational, Real, Number\nnumbers.Real AbstractFloat, Number, Missing/Nothing (if NaN)\nnumbers.Complex Complex, Number\nctypes.c_int and other integers Integer, Rational, Real, Number\nctypes.c_float/ctypes.c_double Cfloat/Cdouble, AbstractFloat, Real, Number\nctypes.c_voidp Ptr{Cvoid}, Ptr\nctypes.c_char_p Cstring, Ptr{Cchar}, Ptr\nctypes.c_wchar_p Cwstring, Ptr{Cwchar}, Ptr\nnumpy.intXX/numpy.uintXX/numpy.floatXX Integer, Rational, Real, Number\nObjects satisfying the buffer or array interface Array, AbstractArray\nLow priority (fallback to Py). \nAnything Py\nBottom priority (must be explicitly specified by excluding Py). \nObjects satisfying the buffer interface PyBuffer\nAnything PyRef","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"See below for an explanation of the Py* types (PyList, PyIO, etc).","category":"page"},{"location":"conversion-to-julia/#py2jl-conversion-custom","page":"Conversion to Julia","title":"Custom rules","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"To add a custom conversion rule, you must define a function to do the conversion and call pyconvert_add_rule to register it.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"You must not do this while precompiling, so these calls will normally be in the __init__ function of your module.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"PythonCall.pyconvert_add_rule","category":"page"},{"location":"conversion-to-julia/#PythonCall.pyconvert_add_rule","page":"Conversion to Julia","title":"PythonCall.pyconvert_add_rule","text":"pyconvert_add_rule(tname::String, T::Type, func::Function, priority::PyConvertPriority=PYCONVERT_PRIORITY_NORMAL)\n\nAdd a new conversion rule for pyconvert.\n\nArguments\n\ntname is a string of the form \"__module__:__qualname__\" identifying a Python type t, such as \"builtins:dict\". This rule only applies to Python objects of this type.\nT is a Julia type, such that this rule only applies when the target type intersects with T.\nfunc is the function implementing the rule.\npriority determines whether to prioritise this rule above others.\n\nWhen pyconvert(R, x) is called, all rules such that typeintersect(T, R) != Union{} and pyisinstance(x, t) are considered. These rules are sorted first by priority, then by the specificity of t (e.g. bool is more specific than int is more specific than object) then by the order they were added. The rules are tried in turn until one succeeds.\n\nImplemeting func\n\nfunc is called as func(S, x::Py) for some S <: T.\n\nIt must return one of:\n\npyconvert_return(ans) where ans is the result of the conversion (and must be an S).\npyconvert_unconverted() if the conversion was not possible (e.g. converting a list to Vector{Int} might fail if some of the list items are not integers).\n\nThe target type S is never a union or the empty type, i.e. it is always a data type or union-all.\n\nPriority\n\nMost rules should have priority PYCONVERT_PRIORITY_NORMAL (the default) which is for any reasonable conversion rule.\n\nUse priority PYCONVERT_PRIORITY_CANONICAL for canonical conversion rules. Immutable objects may be canonically converted to their corresponding Julia type, such as int to Integer. Mutable objects must be converted to a wrapper type, such that the original Python object can be retrieved. For example a list is canonically converted to PyList and not to a Vector. There should not be more than one canonical conversion rule for a given Python type.\n\nOther priorities are reserved for internal use.\n\nOptional optimization (for experts)\n\nThe func is given the only reference to x. This means it may call pydel!(x) when done with x provided x is not referenced anywhere else, such as in the return value. See pydel!.\n\nIf you are returning a wrapper type, such as PyList(x), then the object x should be duplicated first, as in Py(x). It is recommended to force this in the inner constructor of the wrapper type.\n\n\n\n\n\n","category":"function"},{"location":"conversion-to-julia/#python-wrappers","page":"Conversion to Julia","title":"Wrapper types","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"The following types wrap a Python object, giving it the semantics of a Julia object. For example PyList(x) interprets the Python sequence x as a Julia abstract vector.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"Apart from a few fundamental immutable types, conversion from Python to Julia Any will return a wrapper type such as one of these, or simply Py if no wrapper type is suitable.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyIO\nPyTable\nPyPandasDataFrame\nPyObjectArray\nPyException","category":"page"},{"location":"conversion-to-julia/#PythonCall.PyList","page":"Conversion to Julia","title":"PythonCall.PyList","text":"PyList{T=Py}([x])\n\nWraps the Python list x (or anything satisfying the sequence interface) as an AbstractVector{T}.\n\nIf x is not a Python object, it is converted to one using pylist.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PySet","page":"Conversion to Julia","title":"PythonCall.PySet","text":"PySet{T=Py}([x])\n\nWraps the Python set x (or anything satisfying the set interface) as an AbstractSet{T}.\n\nIf x is not a Python object, it is converted to one using pyset.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyDict","page":"Conversion to Julia","title":"PythonCall.PyDict","text":"PyDict{K=Py,V=Py}([x])\n\nWraps the Python dict x (or anything satisfying the mapping interface) as an AbstractDict{K,V}.\n\nIf x is not a Python object, it is converted to one using pydict.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyIterable","page":"Conversion to Julia","title":"PythonCall.PyIterable","text":"PyIterable{T=Py}(x)\n\nThis object iterates over iterable Python object x, yielding values of type T.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyArray","page":"Conversion to Julia","title":"PythonCall.PyArray","text":"PyArray{T,N,M,L,R}(x; copy=true, array=true, buffer=true)\n\nWrap the Python array x as a Julia AbstractArray{T,N}.\n\nThe input x can be bytes, bytearray, array.array, numpy.ndarray or anything satisfying the buffer protocol (if buffer=true) or the numpy array interface (if array=true).\n\nIf copy=false then the resulting array is guaranteed to directly wrap the data in x. If copy=true then a copy is taken if necessary to produce an array.\n\nThe type parameters are all optional, and are:\n\nT: The element type.\nN: The number of dimensions.\nM: True if the array is mutable.\nL: True if the array supports fast linear indexing.\nR: The element type of the underlying buffer. Equal to T for scalar numeric types.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyIO","page":"Conversion to Julia","title":"PythonCall.PyIO","text":"PyIO(x; own=false, text=missing, buflen=4096)\n\nWrap the Python IO stream x as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then x must be a binary stream and arbitrary binary I/O is possible. If text=true then x must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If x is a text stream and you really need a binary stream, then often PyIO(x.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to x. The size of the buffers is buflen. The buffers are cleared using flush.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyTable","page":"Conversion to Julia","title":"PythonCall.PyTable","text":"PyTable\n\nAbstract type for Python wrappers which may be interpretable as Tables.jl-compatible tables.\n\nIf pyconvert(PyTable, x::Py) is a table, then x is also a table.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyPandasDataFrame","page":"Conversion to Julia","title":"PythonCall.PyPandasDataFrame","text":"PyPandasDataFrame(x; indexname=nothing, columntypes=())\n\nWraps the pandas DataFrame x as a Tables.jl-compatible table.\n\nindexname is the name of the column to contain the index. It may be nothing to exclude the index.\n\ncolumntypes is a mapping of column names to column element types, in case automatic deduction does not work.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyObjectArray","page":"Conversion to Julia","title":"PythonCall.PyObjectArray","text":"PyObjectArray(undef, dims...)\nPyObjectArray(array)\n\nAn array of Pys which supports the Python buffer protocol.\n\nInternally, the objects are stored as an array of pointers.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyException","page":"Conversion to Julia","title":"PythonCall.PyException","text":"PyException(x)\n\nWraps the Python exception x as a Julia Exception.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#python-wrappers-custom","page":"Conversion to Julia","title":"Custom wrappers","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"Here is a minimal example of defining a wrapper type. You may add methods, fields and a supertype to the type to specialise its behaviour. See any of the above wrapper types for examples.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"# The new type with a field for the Python object being wrapped.\nstruct MyType\n    py::Py\nend\n\n# Says that the object is a wrapper.\nispy(x::MyType) = true\n\n# Says how to access the underlying Python object.\ngetpy(x::MyType) = x.py","category":"page"},{"location":"pycall/#Coming-from-*PyCall*?","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Another similar interface to Python is provided by PyCall.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"On this page, we give some tips for migrating between the two modules and a comparison.","category":"page"},{"location":"pycall/#Tips","page":"Coming from PyCall?","title":"Tips","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"You can use both PyCall and PythonCall in the same Julia session (this might be platform dependent).\nTo force PythonCall to use the same Python interpreter as PyCall, set the environment variable JULIA_PYTHONCALL_EXE to \"@PyCall\".","category":"page"},{"location":"pycall/#Comparison","page":"Coming from PyCall?","title":"Comparison","text":"","category":"section"},{"location":"pycall/#Flexibility-of-conversion","page":"Coming from PyCall?","title":"Flexibility of conversion","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"In PyCall you do convert(T, x) to convert the Python object x to a Julia T. In PythonCall you similarly do pyconvert(T, x).","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"PythonCall supports far more combinations of types of T and x. For example convert(Vector, x) in PyCall requires x to be a sequence, whereas in PythonCall pyconvert(Vector, x) works if x is an iterable, an object supporting the buffer protocol (such as bytes) or an object supporting the numpy array interface (such as numpy.ndarray).","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Furthermore, pyconvert can be extended to support more types, whereas convert(Vector, x) cannot support more Python types.","category":"page"},{"location":"pycall/#Lossiness-of-conversion","page":"Coming from PyCall?","title":"Lossiness of conversion","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Both packages allow conversion of Julia values to Python: PyObject(x) in PyCall, Py(x) in PythonCall.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Whereas both packages convert numbers, booleans, tuples and strings to their Python counterparts, they differ in handling other types. For example PyCall converts AbstractVector to list whereas PythonCall converts AbstractVector to juliacall.VectorValue which is a sequence type directly wrapping the Julia value - this has the advantage that mutating the Python object also mutates the original Julia object.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Hence with PyCall the following does not mutate the original array x:","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"x = [\"foo\", \"bar\"]\nPyObject(x).append(\"baz\")\n@show x # --> [\"foo\", \"bar\"]","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"whereas with PythonCall the following does mutate x:","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"x = [\"foo\", \"bar\"]\nPy(x).append(\"baz\")\n@show x # --> [\"foo\", \"bar\", \"baz\"]","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"In fact, PythonCall has the policy that any mutable object will by default be wrapped in this way, which not only preserves mutability but makes conversion faster for large containers since it does not require taking a copy of all the data.","category":"page"},{"location":"pycall/#Automatic-conversion","page":"Coming from PyCall?","title":"Automatic conversion","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"In PyCall, most function calls, attribute accesses, indexing, etc. of Python object by default automatically convert their result to a Julia object. This means that the following","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"pyimport(\"sys\").modules[\"KEY\"] = \"VALUE\"","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"does not actually modify the modules dict because it was copied to a new Julia Dict. This was probably not intended, plus it wasted time copying the whole dictionary. Instead you must do","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"set!(pyimport(os).\"environ\", \"KEY\", \"VALUE\")","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"In PythonCall, we don't do any such automatic conversion: we always return Py. This means that the first piece of code above does what you think.","category":"page"},{"location":"pycall/#Which-Python","page":"Coming from PyCall?","title":"Which Python","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"PyCall uses some global installation of Python - typically the version of Python installed on the system or used by Conda.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"PythonCall uses a separate Conda environment for each Julia environment/project/package and installs Python (and other Python packages) into that. This means that different Julia projects can maintain an isolated set of Python dependencies (including the Python version itself).","category":"page"},{"location":"pycall/#Corresponding-Python-packages","page":"Coming from PyCall?","title":"Corresponding Python packages","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"PyCall has the corresponding Python package PyJulia for calling Julia from Python, and PythonCall similarly has JuliaCall.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"One difference is between them is their code size: PyJulia is a large package, whereas JuliaCall is very small, with most of the implementation being in PythonCall itself. The practical up-shot is that PythonCall/JuliaCall have very symmetric interfaces; for example they use identical conversion policies and have the same set of wrapper types available.","category":"page"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"Note also that JuliaCall will use a separate Julia project for each virtual/conda environment. This means that different Python environments can maintain an isolated set of Julia dependencies, including the versions of Julia and PythonCall themselves.","category":"page"},{"location":"pycall/#Compatibility","page":"Coming from PyCall?","title":"Compatibility","text":"","category":"section"},{"location":"pycall/","page":"Coming from PyCall?","title":"Coming from PyCall?","text":"PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.4+ and Python 3.5+. PyCall requires numpy to be installed, PythonCall doesn't (it provides the same fast array access through the buffer protocol and array interface).","category":"page"}]
}
